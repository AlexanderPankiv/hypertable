#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Hypertable::ThriftGen::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Hypertable::ThriftGen::ClientService_create_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_table_args->mk_accessors( qw( name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 2);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_args->mk_accessors( qw( name scan_spec retry_table_not_found ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  $self->{retry_table_not_found} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
    if (defined $vals->{retry_table_not_found}) {
      $self->{retry_table_not_found} = $vals->{retry_table_not_found};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{retry_table_not_found});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 2);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{retry_table_not_found}) {
    $xfer += $output->writeFieldBegin('retry_table_not_found', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{retry_table_not_found});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{success} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem26->read($input);
            push(@{$self->{success}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter27 (@{$self->{success}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{success} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            {
              my $_size34 = 0;
              $elem33 = [];
              my $_etype37 = 0;
              $xfer += $input->readListBegin(\$_etype37, \$_size34);
              for (my $_i38 = 0; $_i38 < $_size34; ++$_i38)
              {
                my $elem39 = undef;
                $xfer += $input->readString(\$elem39);
                push(@{$elem33},$elem39);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter40 (@{$self->{success}}) 
        {
          {
            $output->writeListBegin(TType::STRING, scalar(@{${iter40}}));
            {
              foreach my $iter41 (@{${iter40}}) 
              {
                $xfer += $output->writeString($iter41);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{success} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $elem47 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem47->read($input);
            push(@{$self->{success}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter48 (@{$self->{success}}) 
        {
          $xfer += ${iter48}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size49 = 0;
          $self->{success} = [];
          my $_etype52 = 0;
          $xfer += $input->readListBegin(\$_etype52, \$_size49);
          for (my $_i53 = 0; $_i53 < $_size49; ++$_i53)
          {
            my $elem54 = undef;
            {
              my $_size55 = 0;
              $elem54 = [];
              my $_etype58 = 0;
              $xfer += $input->readListBegin(\$_etype58, \$_size55);
              for (my $_i59 = 0; $_i59 < $_size55; ++$_i59)
              {
                my $elem60 = undef;
                $xfer += $input->readString(\$elem60);
                push(@{$elem54},$elem60);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem54);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter61 (@{$self->{success}}) 
        {
          {
            $output->writeListBegin(TType::STRING, scalar(@{${iter61}}));
            {
              foreach my $iter62 (@{${iter61}}) 
              {
                $xfer += $output->writeString($iter62);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_args->mk_accessors( qw( name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size63 = 0;
          $self->{success} = [];
          my $_etype66 = 0;
          $xfer += $input->readListBegin(\$_etype66, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $elem68 = undef;
            $elem68 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem68->read($input);
            push(@{$self->{success}},$elem68);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter69 (@{$self->{success}}) 
        {
          $xfer += ${iter69}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_args->mk_accessors( qw( name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size70 = 0;
          $self->{success} = [];
          my $_etype73 = 0;
          $xfer += $input->readListBegin(\$_etype73, \$_size70);
          for (my $_i74 = 0; $_i74 < $_size70; ++$_i74)
          {
            my $elem75 = undef;
            {
              my $_size76 = 0;
              $elem75 = [];
              my $_etype79 = 0;
              $xfer += $input->readListBegin(\$_etype79, \$_size76);
              for (my $_i80 = 0; $_i80 < $_size76; ++$_i80)
              {
                my $elem81 = undef;
                $xfer += $input->readString(\$elem81);
                push(@{$elem75},$elem81);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem75);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter82 (@{$self->{success}}) 
        {
          {
            $output->writeListBegin(TType::STRING, scalar(@{${iter82}}));
            {
              foreach my $iter83 (@{${iter82}}) 
              {
                $xfer += $output->writeString($iter83);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_args->mk_accessors( qw( name row column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_args->mk_accessors( qw( name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 2);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size84 = 0;
          $self->{success} = [];
          my $_etype87 = 0;
          $xfer += $input->readListBegin(\$_etype87, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $elem89 = undef;
            $elem89 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem89->read($input);
            push(@{$self->{success}},$elem89);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter90 (@{$self->{success}}) 
        {
          $xfer += ${iter90}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args->mk_accessors( qw( name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 2);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size91 = 0;
          $self->{success} = [];
          my $_etype94 = 0;
          $xfer += $input->readListBegin(\$_etype94, \$_size91);
          for (my $_i95 = 0; $_i95 < $_size91; ++$_i95)
          {
            my $elem96 = undef;
            {
              my $_size97 = 0;
              $elem96 = [];
              my $_etype100 = 0;
              $xfer += $input->readListBegin(\$_etype100, \$_size97);
              for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
              {
                my $elem102 = undef;
                $xfer += $input->readString(\$elem102);
                push(@{$elem96},$elem102);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem96);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter103 (@{$self->{success}}) 
        {
          {
            $output->writeListBegin(TType::STRING, scalar(@{${iter103}}));
            {
              foreach my $iter104 (@{${iter103}}) 
              {
                $xfer += $output->writeString($iter104);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cells_args->mk_accessors( qw( tablename mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tablename} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size105 = 0;
          $self->{cells} = [];
          my $_etype108 = 0;
          $xfer += $input->readListBegin(\$_etype108, \$_size105);
          for (my $_i109 = 0; $_i109 < $_size105; ++$_i109)
          {
            my $elem110 = undef;
            $elem110 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem110->read($input);
            push(@{$self->{cells}},$elem110);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cells_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 2);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter111 (@{$self->{cells}}) 
        {
          $xfer += ${iter111}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cells_as_arrays_args->mk_accessors( qw( tablename mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tablename} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size112 = 0;
          $self->{cells} = [];
          my $_etype115 = 0;
          $xfer += $input->readListBegin(\$_etype115, \$_size112);
          for (my $_i116 = 0; $_i116 < $_size112; ++$_i116)
          {
            my $elem117 = undef;
            {
              my $_size118 = 0;
              $elem117 = [];
              my $_etype121 = 0;
              $xfer += $input->readListBegin(\$_etype121, \$_size118);
              for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
              {
                my $elem123 = undef;
                $xfer += $input->readString(\$elem123);
                push(@{$elem117},$elem123);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem117);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cells_as_arrays_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 2);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 3);
    {
      $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter124 (@{$self->{cells}}) 
        {
          {
            $output->writeListBegin(TType::STRING, scalar(@{${iter124}}));
            {
              foreach my $iter125 (@{${iter124}}) 
              {
                $xfer += $output->writeString($iter125);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cell_args->mk_accessors( qw( tablename mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tablename} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cell_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 2);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 3);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cell_as_array_args->mk_accessors( qw( tablename mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tablename} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tablename}) {
      $self->{tablename} = $vals->{tablename};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tablename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size126 = 0;
          $self->{cell} = [];
          my $_etype129 = 0;
          $xfer += $input->readListBegin(\$_etype129, \$_size126);
          for (my $_i130 = 0; $_i130 < $_size126; ++$_i130)
          {
            my $elem131 = undef;
            $xfer += $input->readString(\$elem131);
            push(@{$self->{cell}},$elem131);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cell_as_array_args');
  if (defined $self->{tablename}) {
    $xfer += $output->writeFieldBegin('tablename', TType::STRING, 1);
    $xfer += $output->writeString($self->{tablename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 2);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter132 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter132);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_put_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_put_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_put_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_put_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_args->mk_accessors( qw( name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 2);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', TType::I32, 3);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_args->mk_accessors( qw( mutator flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{flush} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size133 = 0;
          $self->{cell} = [];
          my $_etype136 = 0;
          $xfer += $input->readListBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $xfer += $input->readString(\$elem138);
            push(@{$self->{cell}},$elem138);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter139 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter139);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size140 = 0;
          $self->{cells} = [];
          my $_etype143 = 0;
          $xfer += $input->readListBegin(\$_etype143, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $elem145 = undef;
            $elem145 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem145->read($input);
            push(@{$self->{cells}},$elem145);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter146 (@{$self->{cells}}) 
        {
          $xfer += ${iter146}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size147 = 0;
          $self->{cells} = [];
          my $_etype150 = 0;
          $xfer += $input->readListBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            {
              my $_size153 = 0;
              $elem152 = [];
              my $_etype156 = 0;
              $xfer += $input->readListBegin(\$_etype156, \$_size153);
              for (my $_i157 = 0; $_i157 < $_size153; ++$_i157)
              {
                my $elem158 = undef;
                $xfer += $input->readString(\$elem158);
                push(@{$elem152},$elem158);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem152);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter159 (@{$self->{cells}}) 
        {
          {
            $output->writeListBegin(TType::STRING, scalar(@{${iter159}}));
            {
              foreach my $iter160 (@{${iter159}}) 
              {
                $xfer += $output->writeString($iter160);
              }
            }
            $output->writeListEnd();
          }
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size161 = 0;
          $self->{success} = [];
          my $_etype164 = 0;
          $xfer += $input->readListBegin(\$_etype164, \$_size161);
          for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
          {
            my $elem166 = undef;
            $xfer += $input->readString(\$elem166);
            push(@{$self->{success}},$elem166);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter167 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter167);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_args->mk_accessors( qw( name if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientServiceIf;

use strict;


sub create_table{
  my $self = shift;
  my $name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub open_scanner{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;
  my $retry_table_not_found = shift;

  die 'implement interface';
}

sub close_scanner{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub get_row{
  my $self = shift;
  my $name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_as_arrays{
  my $self = shift;
  my $name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_cell{
  my $self = shift;
  my $name = shift;
  my $row = shift;
  my $column = shift;

  die 'implement interface';
}

sub get_cells{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_as_arrays{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub put_cells{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub put_cells_as_arrays{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub put_cell{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub put_cell_as_array{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub open_mutator{
  my $self = shift;
  my $name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub close_mutator{
  my $self = shift;
  my $mutator = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub get_table_id{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}

package Hypertable::ThriftGen::ClientServiceRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub create_table{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->create_table($name, $schema);
}

sub open_scanner{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  my $retry_table_not_found = ($request->{'retry_table_not_found'}) ? $request->{'retry_table_not_found'} : undef;
  return $self->{impl}->open_scanner($name, $scan_spec, $retry_table_not_found);
}

sub close_scanner{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner($scanner);
}

sub next_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells($scanner);
}

sub next_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_as_arrays($scanner);
}

sub next_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row($scanner);
}

sub next_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_as_arrays($scanner);
}

sub get_row{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row($name, $row);
}

sub get_row_as_arrays{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_as_arrays($name, $row);
}

sub get_cell{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  return $self->{impl}->get_cell($name, $row, $column);
}

sub get_cells{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells($name, $scan_spec);
}

sub get_cells_as_arrays{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_as_arrays($name, $scan_spec);
}

sub put_cells{
  my ($self, $request) = @_;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->put_cells($tablename, $mutate_spec, $cells);
}

sub put_cells_as_arrays{
  my ($self, $request) = @_;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->put_cells_as_arrays($tablename, $mutate_spec, $cells);
}

sub put_cell{
  my ($self, $request) = @_;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->put_cell($tablename, $mutate_spec, $cell);
}

sub put_cell_as_array{
  my ($self, $request) = @_;

  my $tablename = ($request->{'tablename'}) ? $request->{'tablename'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->put_cell_as_array($tablename, $mutate_spec, $cell);
}

sub open_mutator{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->open_mutator($name, $flags, $flush_interval);
}

sub close_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->close_mutator($mutator, $flush);
}

sub set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell($mutator, $cell);
}

sub set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array($mutator, $cell);
}

sub set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells($mutator, $cells);
}

sub set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays($mutator, $cells);
}

sub flush_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator($mutator);
}

sub get_table_id{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_table_id($name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_schema($name);
}

sub get_tables{
  my ($self, $request) = @_;

  return $self->{impl}->get_tables();
}

sub drop_table{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_table($name, $if_exists);
}

package Hypertable::ThriftGen::ClientServiceClient;


use base qw(Hypertable::ThriftGen::ClientServiceIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub create_table{
  my $self = shift;
  my $name = shift;
  my $schema = shift;

    $self->send_create_table($name, $schema);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
  $args->{name} = $name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub open_scanner{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;
  my $retry_table_not_found = shift;

    $self->send_open_scanner($name, $scan_spec, $retry_table_not_found);
  return $self->recv_open_scanner();
}

sub send_open_scanner{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;
  my $retry_table_not_found = shift;

  $self->{output}->writeMessageBegin('open_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->{retry_table_not_found} = $retry_table_not_found;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner failed: unknown result";
}
sub close_scanner{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner($scanner);
  $self->recv_close_scanner();
}

sub send_close_scanner{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub next_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells($scanner);
  return $self->recv_next_cells();
}

sub send_next_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells failed: unknown result";
}
sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_as_arrays($scanner);
  return $self->recv_next_cells_as_arrays();
}

sub send_next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells_as_arrays failed: unknown result";
}
sub next_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row($scanner);
  return $self->recv_next_row();
}

sub send_next_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row failed: unknown result";
}
sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_as_arrays($scanner);
  return $self->recv_next_row_as_arrays();
}

sub send_next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_as_arrays failed: unknown result";
}
sub get_row{
  my $self = shift;
  my $name = shift;
  my $row = shift;

    $self->send_get_row($name, $row);
  return $self->recv_get_row();
}

sub send_get_row{
  my $self = shift;
  my $name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
  $args->{name} = $name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row failed: unknown result";
}
sub get_row_as_arrays{
  my $self = shift;
  my $name = shift;
  my $row = shift;

    $self->send_get_row_as_arrays($name, $row);
  return $self->recv_get_row_as_arrays();
}

sub send_get_row_as_arrays{
  my $self = shift;
  my $name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_args();
  $args->{name} = $name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_as_arrays failed: unknown result";
}
sub get_cell{
  my $self = shift;
  my $name = shift;
  my $row = shift;
  my $column = shift;

    $self->send_get_cell($name, $row, $column);
  return $self->recv_get_cell();
}

sub send_get_cell{
  my $self = shift;
  my $name = shift;
  my $row = shift;
  my $column = shift;

  $self->{output}->writeMessageBegin('get_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
  $args->{name} = $name;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cell failed: unknown result";
}
sub get_cells{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells($name, $scan_spec);
  return $self->recv_get_cells();
}

sub send_get_cells{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells failed: unknown result";
}
sub get_cells_as_arrays{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_as_arrays($name, $scan_spec);
  return $self->recv_get_cells_as_arrays();
}

sub send_get_cells_as_arrays{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args();
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_as_arrays failed: unknown result";
}
sub put_cells{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_put_cells($tablename, $mutate_spec, $cells);
  $self->recv_put_cells();
}

sub send_put_cells{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('put_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_put_cells_args();
  $args->{tablename} = $tablename;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_put_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_put_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub put_cells_as_arrays{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_put_cells_as_arrays($tablename, $mutate_spec, $cells);
  $self->recv_put_cells_as_arrays();
}

sub send_put_cells_as_arrays{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('put_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_put_cells_as_arrays_args();
  $args->{tablename} = $tablename;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_put_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_put_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub put_cell{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_put_cell($tablename, $mutate_spec, $cell);
  $self->recv_put_cell();
}

sub send_put_cell{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('put_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_put_cell_args();
  $args->{tablename} = $tablename;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_put_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_put_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub put_cell_as_array{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_put_cell_as_array($tablename, $mutate_spec, $cell);
  $self->recv_put_cell_as_array();
}

sub send_put_cell_as_array{
  my $self = shift;
  my $tablename = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('put_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_put_cell_as_array_args();
  $args->{tablename} = $tablename;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_put_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_put_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub open_mutator{
  my $self = shift;
  my $name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_open_mutator($name, $flags, $flush_interval);
  return $self->recv_open_mutator();
}

sub send_open_mutator{
  my $self = shift;
  my $name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('open_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
  $args->{name} = $name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator failed: unknown result";
}
sub close_mutator{
  my $self = shift;
  my $mutator = shift;
  my $flush = shift;

    $self->send_close_mutator($mutator, $flush);
  $self->recv_close_mutator();
}

sub send_close_mutator{
  my $self = shift;
  my $mutator = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('close_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
  $args->{mutator} = $mutator;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell($mutator, $cell);
  $self->recv_set_cell();
}

sub send_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_as_array($mutator, $cell);
  $self->recv_set_cell_as_array();
}

sub send_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells($mutator, $cells);
  $self->recv_set_cells();
}

sub send_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays($mutator, $cells);
  $self->recv_set_cells_as_arrays();
}

sub send_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator($mutator);
  $self->recv_flush_mutator();
}

sub send_flush_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub get_table_id{
  my $self = shift;
  my $name = shift;

    $self->send_get_table_id($name);
  return $self->recv_get_table_id();
}

sub send_get_table_id{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_table_id', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_id failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $name = shift;

    $self->send_get_schema($name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema failed: unknown result";
}
sub get_tables{
  my $self = shift;

    $self->send_get_tables();
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_tables failed: unknown result";
}
sub drop_table{
  my $self = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_drop_table($name, $if_exists);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
package Hypertable::ThriftGen::ClientServiceProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_create_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
    eval {
      $self->{handler}->create_table($args->name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
    eval {
      $result->{success} = $self->{handler}->open_scanner($args->name, $args->scan_spec, $args->retry_table_not_found);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_scanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
    eval {
      $self->{handler}->close_scanner($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_scanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
    eval {
      $result->{success} = $self->{handler}->next_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->next_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_result();
    eval {
      $result->{success} = $self->{handler}->next_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->next_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
    eval {
      $result->{success} = $self->{handler}->get_row($args->name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_row_as_arrays($args->name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
    eval {
      $result->{success} = $self->{handler}->get_cell($args->name, $args->row, $args->column);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
    eval {
      $result->{success} = $self->{handler}->get_cells($args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_cells_as_arrays($args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_put_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_put_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_put_cells_result();
    eval {
      $self->{handler}->put_cells($args->tablename, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('put_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_put_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_put_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_put_cells_as_arrays_result();
    eval {
      $self->{handler}->put_cells_as_arrays($args->tablename, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('put_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_put_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_put_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_put_cell_result();
    eval {
      $self->{handler}->put_cell($args->tablename, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('put_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_put_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_put_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_put_cell_as_array_result();
    eval {
      $self->{handler}->put_cell_as_array($args->tablename, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('put_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
    eval {
      $result->{success} = $self->{handler}->open_mutator($args->name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
    eval {
      $self->{handler}->close_mutator($args->mutator, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
    eval {
      $self->{handler}->set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_result();
    eval {
      $self->{handler}->set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
    eval {
      $self->{handler}->set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result();
    eval {
      $self->{handler}->set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
    eval {
      $self->{handler}->flush_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('flush_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_id {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
    eval {
      $result->{success} = $self->{handler}->get_table_id($args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_table_id', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_tables();
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
    eval {
      $self->{handler}->drop_table($args->name, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
