#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Hypertable::ThriftGen::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Hypertable::ThriftGen::ClientService_create_table_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_create_table_args->mk_accessors( qw( name schema ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_create_table_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 2);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_table_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_create_table_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_create_table_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_open_scanner_args->mk_accessors( qw( name scan_spec ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_open_scanner_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 2);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_open_scanner_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_open_scanner_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_close_scanner_args->mk_accessors( qw( scanner ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_close_scanner_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_close_scanner_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_close_scanner_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_next_cells_args->mk_accessors( qw( scanner ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_next_cells_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_next_cells_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_next_cells_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{success} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem19->read($input);
            push(@{$self->{success}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter20 (@{$self->{success}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_row_args->mk_accessors( qw( name row ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_row_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_row_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_row_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{success} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem26->read($input);
            push(@{$self->{success}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter27 (@{$self->{success}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_cell_args->mk_accessors( qw( name row column ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{row} = undef;
$self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_cell_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_cell_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_cell_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_cells_args->mk_accessors( qw( name scan_spec ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_cells_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 2);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_cells_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_cells_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{success} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem33->read($input);
            push(@{$self->{success}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter34 (@{$self->{success}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_open_mutator_args->mk_accessors( qw( name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_open_mutator_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_open_mutator_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_open_mutator_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_close_mutator_args->mk_accessors( qw( mutator flush ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{mutator} = undef;
$self->{flush} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_close_mutator_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_close_mutator_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_close_mutator_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_set_cell_args->mk_accessors( qw( mutator cell ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{mutator} = undef;
$self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_set_cell_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_set_cell_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_set_cell_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_set_cells_args->mk_accessors( qw( mutator cells ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{mutator} = undef;
$self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_set_cells_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{cells} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $elem40 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem40->read($input);
            push(@{$self->{cells}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter41 (@{$self->{cells}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_set_cells_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_set_cells_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_flush_mutator_args->mk_accessors( qw( mutator ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_flush_mutator_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_flush_mutator_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_flush_mutator_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_table_id_args->mk_accessors( qw( name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_table_id_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_table_id_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_table_id_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_schema_args->mk_accessors( qw( name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_schema_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_schema_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_schema_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_args;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_tables_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_get_tables_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_get_tables_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{success} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $xfer += $input->readString(\$elem47);
            push(@{$self->{success}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter48 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter48);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_args;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_drop_table_args->mk_accessors( qw( name if_exists ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_drop_table_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_result;
use base('Class::Accessor');
Hypertable::ThriftGen::ClientService_drop_table_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ClientService_drop_table_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ClientServiceIf;

sub create_table{
  my $self = shift;
  my $name = shift;
  my $schema = shift;

  die 'implement interface';
}
sub open_scanner{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}
sub close_scanner{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}
sub next_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}
sub get_row{
  my $self = shift;
  my $name = shift;
  my $row = shift;

  die 'implement interface';
}
sub get_cell{
  my $self = shift;
  my $name = shift;
  my $row = shift;
  my $column = shift;

  die 'implement interface';
}
sub get_cells{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}
sub open_mutator{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}
sub close_mutator{
  my $self = shift;
  my $mutator = shift;
  my $flush = shift;

  die 'implement interface';
}
sub set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}
sub set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}
sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}
sub get_table_id{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}
sub get_schema{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}
sub get_tables{
  my $self = shift;

  die 'implement interface';
}
sub drop_table{
  my $self = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}
package ClientServiceRest;

sub new {
  my $classname=shift;
  my $impl     =shift;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub create_table{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->create_table($name, $schema);
}

sub open_scanner{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner($name, $scan_spec);
}

sub close_scanner{
  my $self = shift;
  my $request = shift;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner($scanner);
}

sub next_cells{
  my $self = shift;
  my $request = shift;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells($scanner);
}

sub get_row{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row($name, $row);
}

sub get_cell{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  return $self->{impl}->get_cell($name, $row, $column);
}

sub get_cells{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells($name, $scan_spec);
}

sub open_mutator{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->open_mutator($name);
}

sub close_mutator{
  my $self = shift;
  my $request = shift;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->close_mutator($mutator, $flush);
}

sub set_cell{
  my $self = shift;
  my $request = shift;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell($mutator, $cell);
}

sub set_cells{
  my $self = shift;
  my $request = shift;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells($mutator, $cells);
}

sub flush_mutator{
  my $self = shift;
  my $request = shift;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator($mutator);
}

sub get_table_id{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_table_id($name);
}

sub get_schema{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_schema($name);
}

sub get_tables{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->get_tables();
}

sub drop_table{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_table($name, $if_exists);
}

package ClientServiceClient;

use base('ClientServiceIf');
sub new {
  my $classname = shift;
  my $input     = shift;
  my $output    = shift;
  my $self      = {};
    $self->{input}  = $input;
    $self->{output} = defined $output ? $output : $input;
    $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub create_table{
  my $self = shift;
  my $name = shift;
  my $schema = shift;

    $self->send_create_table($name, $schema);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
  $args->{name} = $name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub open_scanner{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_open_scanner($name, $scan_spec);
  return $self->recv_open_scanner();
}

sub send_open_scanner{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner failed: unknown result";
}
sub close_scanner{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner($scanner);
  $self->recv_close_scanner();
}

sub send_close_scanner{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub next_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells($scanner);
  return $self->recv_next_cells();
}

sub send_next_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells failed: unknown result";
}
sub get_row{
  my $self = shift;
  my $name = shift;
  my $row = shift;

    $self->send_get_row($name, $row);
  return $self->recv_get_row();
}

sub send_get_row{
  my $self = shift;
  my $name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
  $args->{name} = $name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row failed: unknown result";
}
sub get_cell{
  my $self = shift;
  my $name = shift;
  my $row = shift;
  my $column = shift;

    $self->send_get_cell($name, $row, $column);
  return $self->recv_get_cell();
}

sub send_get_cell{
  my $self = shift;
  my $name = shift;
  my $row = shift;
  my $column = shift;

  $self->{output}->writeMessageBegin('get_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
  $args->{name} = $name;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cell failed: unknown result";
}
sub get_cells{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells($name, $scan_spec);
  return $self->recv_get_cells();
}

sub send_get_cells{
  my $self = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells failed: unknown result";
}
sub open_mutator{
  my $self = shift;
  my $name = shift;

    $self->send_open_mutator($name);
  return $self->recv_open_mutator();
}

sub send_open_mutator{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('open_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator failed: unknown result";
}
sub close_mutator{
  my $self = shift;
  my $mutator = shift;
  my $flush = shift;

    $self->send_close_mutator($mutator, $flush);
  $self->recv_close_mutator();
}

sub send_close_mutator{
  my $self = shift;
  my $mutator = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('close_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
  $args->{mutator} = $mutator;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell($mutator, $cell);
  $self->recv_set_cell();
}

sub send_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells($mutator, $cells);
  $self->recv_set_cells();
}

sub send_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator($mutator);
  $self->recv_flush_mutator();
}

sub send_flush_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub get_table_id{
  my $self = shift;
  my $name = shift;

    $self->send_get_table_id($name);
  return $self->recv_get_table_id();
}

sub send_get_table_id{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_table_id', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_id failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $name = shift;

    $self->send_get_schema($name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema failed: unknown result";
}
sub get_tables{
  my $self = shift;

    $self->send_get_tables();
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_tables failed: unknown result";
}
sub drop_table{
  my $self = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_drop_table($name, $if_exists);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
package ClientServiceProcessor;

sub new {
    my $classname = shift;
    my $handler   = shift;
    my $self      = {};
    $self->{handler} = $handler;
    return bless($self,$classname);
}

sub process {
    my $self   = shift;
    my $input  = shift;
    my $output = shift;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!method_exists($self, $methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
  }

sub process_create_table{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
    eval {
      $self->{handler}->create_table($args->name, $args->schema);
    }; if( UNIVERSAL::isa($@,'ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->getTransport()->flush();
}
sub process_open_scanner{
  my $self = shift;
  my ($seqid, $input, $output); 
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
  $args->read($input);
  $input->readMessageEnd();
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
  eval {
    $result->{success} = $self->{handler}->open_scanner($args->name, $args->scan_spec);
  }; if( UNIVERSAL::isa($@,'ClientException') ){ 
    $result->{e} = $@;
  }
  $output->writeMessageBegin('open_scanner', TMessageType::REPLY, $seqid);
  $result->write($output);
  $output->getTransport()->flush();
}
sub process_close_scanner{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
eval {
  $self->{handler}->close_scanner($args->scanner);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
  $result->{e} = $@;
}
$output->writeMessageBegin('close_scanner', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_next_cells{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
eval {
$result->{success} = $self->{handler}->next_cells($args->scanner);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('next_cells', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_row{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
eval {
$result->{success} = $self->{handler}->get_row($args->name, $args->row);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('get_row', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_cell{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
eval {
$result->{success} = $self->{handler}->get_cell($args->name, $args->row, $args->column);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('get_cell', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_cells{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
eval {
$result->{success} = $self->{handler}->get_cells($args->name, $args->scan_spec);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('get_cells', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_open_mutator{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
eval {
$result->{success} = $self->{handler}->open_mutator($args->name);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('open_mutator', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_close_mutator{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
eval {
$self->{handler}->close_mutator($args->mutator, $args->flush);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('close_mutator', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_set_cell{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
eval {
$self->{handler}->set_cell($args->mutator, $args->cell);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('set_cell', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_set_cells{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
eval {
$self->{handler}->set_cells($args->mutator, $args->cells);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('set_cells', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_flush_mutator{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
eval {
$self->{handler}->flush_mutator($args->mutator);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('flush_mutator', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_table_id{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
eval {
$result->{success} = $self->{handler}->get_table_id($args->name);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('get_table_id', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_schema{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
eval {
$result->{success} = $self->{handler}->get_schema($args->name);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_get_tables{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
eval {
$result->{success} = $self->{handler}->get_tables();
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_drop_table{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
$args->read($input);
$input->readMessageEnd();
my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
eval {
$self->{handler}->drop_table($args->name, $args->if_exists);
}; if( UNIVERSAL::isa($@,'ClientException') ){ 
$result->{e} = $@;
}
$output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
1;
