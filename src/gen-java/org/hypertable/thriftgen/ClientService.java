/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.hypertable.thriftgen;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.apache.log4j.Logger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class ClientService {

  /**
   * The client service mimics the C++ client API, with table, scanner and
   * mutator interface flattened.
   */
  public interface Iface {

    /**
     * Create a table
     * 
     * @param name - table name
     * 
     * @param schema - schema of the table (in xml)
     * 
     * @param name
     * @param schema
     */
    public void create_table(String name, String schema) throws ClientException, TException;

    /**
     * Open a table scanner
     * 
     * @param name - table name
     * 
     * @param scan_spec - scan specification
     * 
     * @param retry_table_not_found - whether to retry upon errors caused by
     *        drop/create tables with the same name
     * 
     * @param name
     * @param scan_spec
     * @param retry_table_not_found
     */
    public long open_scanner(String name, ScanSpec scan_spec, boolean retry_table_not_found) throws ClientException, TException;

    /**
     * Close a table scanner
     * 
     * @param scanner - scanner id to close
     * 
     * @param scanner
     */
    public void close_scanner(long scanner) throws ClientException, TException;

    /**
     * Iterate over cells of a scanner
     * 
     * @param scanner - scanner id
     * 
     * @param scanner
     */
    public List<Cell> next_cells(long scanner) throws ClientException, TException;

    public List<List<String>> next_cells_as_arrays(long scanner) throws ClientException, TException;

    /**
     * Iterate over rows of a scanner
     * 
     * @param scanner - scanner id
     * 
     * @param scanner
     */
    public List<Cell> next_row(long scanner) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param scanner
     */
    public List<List<String>> next_row_as_arrays(long scanner) throws ClientException, TException;

    /**
     * Get a row (convenience method for random access a row)
     * 
     * @param name - table name
     * 
     * @param row - row key
     * 
     * @return a list of cells (with row_keys unset)
     * 
     * @param name
     * @param row
     */
    public List<Cell> get_row(String name, String row) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param name
     * @param row
     */
    public List<List<String>> get_row_as_arrays(String name, String row) throws ClientException, TException;

    /**
     * Get a cell (convenience method for random access a cell)
     * 
     * @param name - table name
     * 
     * @param row - row key
     * 
     * @param column - column name
     * 
     * @return value (byte sequence)
     * 
     * @param name
     * @param row
     * @param column
     */
    public byte[] get_cell(String name, String row, String column) throws ClientException, TException;

    /**
     * Get cells (convenience method for access small amount of cells)
     * 
     * @param name - table name
     * 
     * @param scan_spec - scan specification
     * 
     * @return a list of cells (a cell with no row key set is assumed to have
     *         the same row key as the previous cell)
     * 
     * @param name
     * @param scan_spec
     */
    public List<Cell> get_cells(String name, ScanSpec scan_spec) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param name
     * @param scan_spec
     */
    public List<List<String>> get_cells_as_arrays(String name, ScanSpec scan_spec) throws ClientException, TException;

    /**
     * Open a table mutator
     * 
     * @param name - table name
     * 
     * @param flags - mutator flags
     * 
     * @param flush_interval - auto-flush interval in milliseconds; 0 disables it.
     * 
     * @return mutator id
     * 
     * @param name
     * @param flags
     * @param flush_interval
     */
    public long open_mutator(String name, int flags, int flush_interval) throws ClientException, TException;

    /**
     * Close a table mutator
     * 
     * @param mutator - mutator id to close
     * 
     * @param mutator
     * @param flush
     */
    public void close_mutator(long mutator, boolean flush) throws ClientException, TException;

    /**
     * Set a cell in the table
     * 
     * @param mutator - mutator id
     * 
     * @param cell - the cell to set
     * 
     * @param mutator
     * @param cell
     */
    public void set_cell(long mutator, Cell cell) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param mutator
     * @param cell
     */
    public void set_cell_as_array(long mutator, List<String> cell) throws ClientException, TException;

    /**
     * Put a list of cells into a table
     * 
     * @param mutator - mutator id
     * 
     * @param cells - a list of cells (a cell with no row key set is assumed
     *        to have the same row key as the previous cell)
     * 
     * @param mutator
     * @param cells
     */
    public void set_cells(long mutator, List<Cell> cells) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param mutator
     * @param cells
     */
    public void set_cells_as_arrays(long mutator, List<List<String>> cells) throws ClientException, TException;

    /**
     * Flush mutator buffers
     * 
     * @param mutator
     */
    public void flush_mutator(long mutator) throws ClientException, TException;

    /**
     * Get the id of a table
     * 
     * @param name - table name
     * 
     * @return table id
     * 
     * @param name
     */
    public int get_table_id(String name) throws ClientException, TException;

    /**
     * Get the schema of a table (that can be used with creat_table)
     * 
     * @param name - table name
     * 
     * @return schema string (in xml)
     * 
     * @param name
     */
    public String get_schema(String name) throws ClientException, TException;

    /**
     * Get a list of table names in the cluster
     * 
     * @return a list of table names
     */
    public List<String> get_tables() throws ClientException, TException;

    /**
     * Drop a table
     * 
     * @param name - table name
     * 
     * @param if_exists - if true, don't barf if the table doesn't exist
     * 
     * @param name
     * @param if_exists
     */
    public void drop_table(String name, boolean if_exists) throws ClientException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void create_table(String name, String schema) throws ClientException, TException
    {
      send_create_table(name, schema);
      recv_create_table();
    }

    public void send_create_table(String name, String schema) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create_table", TMessageType.CALL, seqid_));
      create_table_args args = new create_table_args();
      args.name = name;
      args.schema = schema;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_create_table() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      create_table_result result = new create_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public long open_scanner(String name, ScanSpec scan_spec, boolean retry_table_not_found) throws ClientException, TException
    {
      send_open_scanner(name, scan_spec, retry_table_not_found);
      return recv_open_scanner();
    }

    public void send_open_scanner(String name, ScanSpec scan_spec, boolean retry_table_not_found) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_scanner", TMessageType.CALL, seqid_));
      open_scanner_args args = new open_scanner_args();
      args.name = name;
      args.scan_spec = scan_spec;
      args.retry_table_not_found = retry_table_not_found;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_scanner() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      open_scanner_result result = new open_scanner_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_scanner failed: unknown result");
    }

    public void close_scanner(long scanner) throws ClientException, TException
    {
      send_close_scanner(scanner);
      recv_close_scanner();
    }

    public void send_close_scanner(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_scanner", TMessageType.CALL, seqid_));
      close_scanner_args args = new close_scanner_args();
      args.scanner = scanner;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_scanner() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      close_scanner_result result = new close_scanner_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public List<Cell> next_cells(long scanner) throws ClientException, TException
    {
      send_next_cells(scanner);
      return recv_next_cells();
    }

    public void send_next_cells(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_cells", TMessageType.CALL, seqid_));
      next_cells_args args = new next_cells_args();
      args.scanner = scanner;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_next_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      next_cells_result result = new next_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_cells failed: unknown result");
    }

    public List<List<String>> next_cells_as_arrays(long scanner) throws ClientException, TException
    {
      send_next_cells_as_arrays(scanner);
      return recv_next_cells_as_arrays();
    }

    public void send_next_cells_as_arrays(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.CALL, seqid_));
      next_cells_as_arrays_args args = new next_cells_as_arrays_args();
      args.scanner = scanner;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_next_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      next_cells_as_arrays_result result = new next_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_cells_as_arrays failed: unknown result");
    }

    public List<Cell> next_row(long scanner) throws ClientException, TException
    {
      send_next_row(scanner);
      return recv_next_row();
    }

    public void send_next_row(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_row", TMessageType.CALL, seqid_));
      next_row_args args = new next_row_args();
      args.scanner = scanner;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_next_row() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      next_row_result result = new next_row_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_row failed: unknown result");
    }

    public List<List<String>> next_row_as_arrays(long scanner) throws ClientException, TException
    {
      send_next_row_as_arrays(scanner);
      return recv_next_row_as_arrays();
    }

    public void send_next_row_as_arrays(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.CALL, seqid_));
      next_row_as_arrays_args args = new next_row_as_arrays_args();
      args.scanner = scanner;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_next_row_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      next_row_as_arrays_result result = new next_row_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_row_as_arrays failed: unknown result");
    }

    public List<Cell> get_row(String name, String row) throws ClientException, TException
    {
      send_get_row(name, row);
      return recv_get_row();
    }

    public void send_get_row(String name, String row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_row", TMessageType.CALL, seqid_));
      get_row_args args = new get_row_args();
      args.name = name;
      args.row = row;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_get_row() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_row_result result = new get_row_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_row failed: unknown result");
    }

    public List<List<String>> get_row_as_arrays(String name, String row) throws ClientException, TException
    {
      send_get_row_as_arrays(name, row);
      return recv_get_row_as_arrays();
    }

    public void send_get_row_as_arrays(String name, String row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.CALL, seqid_));
      get_row_as_arrays_args args = new get_row_as_arrays_args();
      args.name = name;
      args.row = row;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_get_row_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_row_as_arrays_result result = new get_row_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_row_as_arrays failed: unknown result");
    }

    public byte[] get_cell(String name, String row, String column) throws ClientException, TException
    {
      send_get_cell(name, row, column);
      return recv_get_cell();
    }

    public void send_get_cell(String name, String row, String column) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cell", TMessageType.CALL, seqid_));
      get_cell_args args = new get_cell_args();
      args.name = name;
      args.row = row;
      args.column = column;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_get_cell() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_cell_result result = new get_cell_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cell failed: unknown result");
    }

    public List<Cell> get_cells(String name, ScanSpec scan_spec) throws ClientException, TException
    {
      send_get_cells(name, scan_spec);
      return recv_get_cells();
    }

    public void send_get_cells(String name, ScanSpec scan_spec) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cells", TMessageType.CALL, seqid_));
      get_cells_args args = new get_cells_args();
      args.name = name;
      args.scan_spec = scan_spec;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_get_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_cells_result result = new get_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cells failed: unknown result");
    }

    public List<List<String>> get_cells_as_arrays(String name, ScanSpec scan_spec) throws ClientException, TException
    {
      send_get_cells_as_arrays(name, scan_spec);
      return recv_get_cells_as_arrays();
    }

    public void send_get_cells_as_arrays(String name, ScanSpec scan_spec) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.CALL, seqid_));
      get_cells_as_arrays_args args = new get_cells_as_arrays_args();
      args.name = name;
      args.scan_spec = scan_spec;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_get_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_cells_as_arrays_result result = new get_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cells_as_arrays failed: unknown result");
    }

    public long open_mutator(String name, int flags, int flush_interval) throws ClientException, TException
    {
      send_open_mutator(name, flags, flush_interval);
      return recv_open_mutator();
    }

    public void send_open_mutator(String name, int flags, int flush_interval) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_mutator", TMessageType.CALL, seqid_));
      open_mutator_args args = new open_mutator_args();
      args.name = name;
      args.flags = flags;
      args.flush_interval = flush_interval;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      open_mutator_result result = new open_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_mutator failed: unknown result");
    }

    public void close_mutator(long mutator, boolean flush) throws ClientException, TException
    {
      send_close_mutator(mutator, flush);
      recv_close_mutator();
    }

    public void send_close_mutator(long mutator, boolean flush) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_mutator", TMessageType.CALL, seqid_));
      close_mutator_args args = new close_mutator_args();
      args.mutator = mutator;
      args.flush = flush;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      close_mutator_result result = new close_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cell(long mutator, Cell cell) throws ClientException, TException
    {
      send_set_cell(mutator, cell);
      recv_set_cell();
    }

    public void send_set_cell(long mutator, Cell cell) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cell", TMessageType.CALL, seqid_));
      set_cell_args args = new set_cell_args();
      args.mutator = mutator;
      args.cell = cell;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cell() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      set_cell_result result = new set_cell_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cell_as_array(long mutator, List<String> cell) throws ClientException, TException
    {
      send_set_cell_as_array(mutator, cell);
      recv_set_cell_as_array();
    }

    public void send_set_cell_as_array(long mutator, List<String> cell) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.CALL, seqid_));
      set_cell_as_array_args args = new set_cell_as_array_args();
      args.mutator = mutator;
      args.cell = cell;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cell_as_array() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      set_cell_as_array_result result = new set_cell_as_array_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cells(long mutator, List<Cell> cells) throws ClientException, TException
    {
      send_set_cells(mutator, cells);
      recv_set_cells();
    }

    public void send_set_cells(long mutator, List<Cell> cells) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cells", TMessageType.CALL, seqid_));
      set_cells_args args = new set_cells_args();
      args.mutator = mutator;
      args.cells = cells;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      set_cells_result result = new set_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cells_as_arrays(long mutator, List<List<String>> cells) throws ClientException, TException
    {
      send_set_cells_as_arrays(mutator, cells);
      recv_set_cells_as_arrays();
    }

    public void send_set_cells_as_arrays(long mutator, List<List<String>> cells) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.CALL, seqid_));
      set_cells_as_arrays_args args = new set_cells_as_arrays_args();
      args.mutator = mutator;
      args.cells = cells;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      set_cells_as_arrays_result result = new set_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void flush_mutator(long mutator) throws ClientException, TException
    {
      send_flush_mutator(mutator);
      recv_flush_mutator();
    }

    public void send_flush_mutator(long mutator) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("flush_mutator", TMessageType.CALL, seqid_));
      flush_mutator_args args = new flush_mutator_args();
      args.mutator = mutator;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_flush_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      flush_mutator_result result = new flush_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public int get_table_id(String name) throws ClientException, TException
    {
      send_get_table_id(name);
      return recv_get_table_id();
    }

    public void send_get_table_id(String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_table_id", TMessageType.CALL, seqid_));
      get_table_id_args args = new get_table_id_args();
      args.name = name;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_get_table_id() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_table_id_result result = new get_table_id_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_table_id failed: unknown result");
    }

    public String get_schema(String name) throws ClientException, TException
    {
      send_get_schema(name);
      return recv_get_schema();
    }

    public void send_get_schema(String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_schema", TMessageType.CALL, seqid_));
      get_schema_args args = new get_schema_args();
      args.name = name;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_get_schema() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_schema_result result = new get_schema_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");
    }

    public List<String> get_tables() throws ClientException, TException
    {
      send_get_tables();
      return recv_get_tables();
    }

    public void send_get_tables() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_tables", TMessageType.CALL, seqid_));
      get_tables_args args = new get_tables_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_tables() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_tables_result result = new get_tables_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");
    }

    public void drop_table(String name, boolean if_exists) throws ClientException, TException
    {
      send_drop_table(name, if_exists);
      recv_drop_table();
    }

    public void send_drop_table(String name, boolean if_exists) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_table", TMessageType.CALL, seqid_));
      drop_table_args args = new drop_table_args();
      args.name = name;
      args.if_exists = if_exists;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_drop_table() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      drop_table_result result = new drop_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("create_table", new create_table());
      processMap_.put("open_scanner", new open_scanner());
      processMap_.put("close_scanner", new close_scanner());
      processMap_.put("next_cells", new next_cells());
      processMap_.put("next_cells_as_arrays", new next_cells_as_arrays());
      processMap_.put("next_row", new next_row());
      processMap_.put("next_row_as_arrays", new next_row_as_arrays());
      processMap_.put("get_row", new get_row());
      processMap_.put("get_row_as_arrays", new get_row_as_arrays());
      processMap_.put("get_cell", new get_cell());
      processMap_.put("get_cells", new get_cells());
      processMap_.put("get_cells_as_arrays", new get_cells_as_arrays());
      processMap_.put("open_mutator", new open_mutator());
      processMap_.put("close_mutator", new close_mutator());
      processMap_.put("set_cell", new set_cell());
      processMap_.put("set_cell_as_array", new set_cell_as_array());
      processMap_.put("set_cells", new set_cells());
      processMap_.put("set_cells_as_arrays", new set_cells_as_arrays());
      processMap_.put("flush_mutator", new flush_mutator());
      processMap_.put("get_table_id", new get_table_id());
      processMap_.put("get_schema", new get_schema());
      processMap_.put("get_tables", new get_tables());
      processMap_.put("drop_table", new drop_table());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class create_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_table_args args = new create_table_args();
        args.read(iprot);
        iprot.readMessageEnd();
        create_table_result result = new create_table_result();
        try {
          iface_.create_table(args.name, args.schema);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create_table");
          oprot.writeMessageBegin(new TMessage("create_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_scanner implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_scanner_args args = new open_scanner_args();
        args.read(iprot);
        iprot.readMessageEnd();
        open_scanner_result result = new open_scanner_result();
        try {
          result.success = iface_.open_scanner(args.name, args.scan_spec, args.retry_table_not_found);
          result.__isset.success = true;
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_scanner", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_scanner");
          oprot.writeMessageBegin(new TMessage("open_scanner", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_scanner", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_scanner implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_scanner_args args = new close_scanner_args();
        args.read(iprot);
        iprot.readMessageEnd();
        close_scanner_result result = new close_scanner_result();
        try {
          iface_.close_scanner(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_scanner", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_scanner");
          oprot.writeMessageBegin(new TMessage("close_scanner", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_scanner", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_cells_args args = new next_cells_args();
        args.read(iprot);
        iprot.readMessageEnd();
        next_cells_result result = new next_cells_result();
        try {
          result.success = iface_.next_cells(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_cells");
          oprot.writeMessageBegin(new TMessage("next_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_cells_as_arrays_args args = new next_cells_as_arrays_args();
        args.read(iprot);
        iprot.readMessageEnd();
        next_cells_as_arrays_result result = new next_cells_as_arrays_result();
        try {
          result.success = iface_.next_cells_as_arrays(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_row implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_row_args args = new next_row_args();
        args.read(iprot);
        iprot.readMessageEnd();
        next_row_result result = new next_row_result();
        try {
          result.success = iface_.next_row(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_row", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_row");
          oprot.writeMessageBegin(new TMessage("next_row", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_row", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_row_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_row_as_arrays_args args = new next_row_as_arrays_args();
        args.read(iprot);
        iprot.readMessageEnd();
        next_row_as_arrays_result result = new next_row_as_arrays_result();
        try {
          result.success = iface_.next_row_as_arrays(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_row_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_row_as_arrays");
          oprot.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_row implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_row_args args = new get_row_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_row_result result = new get_row_result();
        try {
          result.success = iface_.get_row(args.name, args.row);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_row", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_row");
          oprot.writeMessageBegin(new TMessage("get_row", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_row", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_row_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_row_as_arrays_args args = new get_row_as_arrays_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_row_as_arrays_result result = new get_row_as_arrays_result();
        try {
          result.success = iface_.get_row_as_arrays(args.name, args.row);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_row_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_row_as_arrays");
          oprot.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cell implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cell_args args = new get_cell_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_cell_result result = new get_cell_result();
        try {
          result.success = iface_.get_cell(args.name, args.row, args.column);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cell", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cell");
          oprot.writeMessageBegin(new TMessage("get_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cell", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cells_args args = new get_cells_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_cells_result result = new get_cells_result();
        try {
          result.success = iface_.get_cells(args.name, args.scan_spec);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cells");
          oprot.writeMessageBegin(new TMessage("get_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cells_as_arrays_args args = new get_cells_as_arrays_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_cells_as_arrays_result result = new get_cells_as_arrays_result();
        try {
          result.success = iface_.get_cells_as_arrays(args.name, args.scan_spec);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_mutator_args args = new open_mutator_args();
        args.read(iprot);
        iprot.readMessageEnd();
        open_mutator_result result = new open_mutator_result();
        try {
          result.success = iface_.open_mutator(args.name, args.flags, args.flush_interval);
          result.__isset.success = true;
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_mutator");
          oprot.writeMessageBegin(new TMessage("open_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_mutator_args args = new close_mutator_args();
        args.read(iprot);
        iprot.readMessageEnd();
        close_mutator_result result = new close_mutator_result();
        try {
          iface_.close_mutator(args.mutator, args.flush);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_mutator");
          oprot.writeMessageBegin(new TMessage("close_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cell implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cell_args args = new set_cell_args();
        args.read(iprot);
        iprot.readMessageEnd();
        set_cell_result result = new set_cell_result();
        try {
          iface_.set_cell(args.mutator, args.cell);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cell", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cell");
          oprot.writeMessageBegin(new TMessage("set_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cell", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cell_as_array implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cell_as_array_args args = new set_cell_as_array_args();
        args.read(iprot);
        iprot.readMessageEnd();
        set_cell_as_array_result result = new set_cell_as_array_result();
        try {
          iface_.set_cell_as_array(args.mutator, args.cell);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cell_as_array", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cell_as_array");
          oprot.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cells_args args = new set_cells_args();
        args.read(iprot);
        iprot.readMessageEnd();
        set_cells_result result = new set_cells_result();
        try {
          iface_.set_cells(args.mutator, args.cells);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cells");
          oprot.writeMessageBegin(new TMessage("set_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cells_as_arrays_args args = new set_cells_as_arrays_args();
        args.read(iprot);
        iprot.readMessageEnd();
        set_cells_as_arrays_result result = new set_cells_as_arrays_result();
        try {
          iface_.set_cells_as_arrays(args.mutator, args.cells);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class flush_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        flush_mutator_args args = new flush_mutator_args();
        args.read(iprot);
        iprot.readMessageEnd();
        flush_mutator_result result = new flush_mutator_result();
        try {
          iface_.flush_mutator(args.mutator);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing flush_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing flush_mutator");
          oprot.writeMessageBegin(new TMessage("flush_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("flush_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_table_id implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_table_id_args args = new get_table_id_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_table_id_result result = new get_table_id_result();
        try {
          result.success = iface_.get_table_id(args.name);
          result.__isset.success = true;
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_table_id", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_table_id");
          oprot.writeMessageBegin(new TMessage("get_table_id", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_table_id", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_schema implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_schema_args args = new get_schema_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_schema_result result = new get_schema_result();
        try {
          result.success = iface_.get_schema(args.name);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_schema", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_schema");
          oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_tables implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_tables_args args = new get_tables_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_tables_result result = new get_tables_result();
        try {
          result.success = iface_.get_tables();
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_tables", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_tables");
          oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_table_args args = new drop_table_args();
        args.read(iprot);
        iprot.readMessageEnd();
        drop_table_result result = new drop_table_result();
        try {
          iface_.drop_table(args.name, args.if_exists);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_table");
          oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class create_table_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_table_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField SCHEMA_FIELD_DESC = new TField("schema", TType.STRING, (short)2);

    public String name;
    public static final int NAME = 1;
    public String schema;
    public static final int SCHEMA = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SCHEMA, new FieldMetaData("schema", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(create_table_args.class, metaDataMap);
    }

    public create_table_args() {
    }

    public create_table_args(
      String name,
      String schema)
    {
      this();
      this.name = name;
      this.schema = schema;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_table_args(create_table_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetSchema()) {
        this.schema = other.schema;
      }
    }

    @Override
    public create_table_args clone() {
      return new create_table_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getSchema() {
      return this.schema;
    }

    public void setSchema(String schema) {
      this.schema = schema;
    }

    public void unsetSchema() {
      this.schema = null;
    }

    // Returns true if field schema is set (has been asigned a value) and false otherwise
    public boolean isSetSchema() {
      return this.schema != null;
    }

    public void setSchemaIsSet(boolean value) {
      if (!value) {
        this.schema = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case SCHEMA:
        if (value == null) {
          unsetSchema();
        } else {
          setSchema((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case SCHEMA:
        return getSchema();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case SCHEMA:
        return isSetSchema();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_table_args)
        return this.equals((create_table_args)that);
      return false;
    }

    public boolean equals(create_table_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_schema = true && this.isSetSchema();
      boolean that_present_schema = true && that.isSetSchema();
      if (this_present_schema || that_present_schema) {
        if (!(this_present_schema && that_present_schema))
          return false;
        if (!this.schema.equals(that.schema))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SCHEMA:
            if (field.type == TType.STRING) {
              this.schema = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.schema != null) {
        oprot.writeFieldBegin(SCHEMA_FIELD_DESC);
        oprot.writeString(this.schema);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_table_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("schema:");
      if (this.schema == null) {
        sb.append("null");
      } else {
        sb.append(this.schema);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class create_table_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_table_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(create_table_result.class, metaDataMap);
    }

    public create_table_result() {
    }

    public create_table_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_table_result(create_table_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public create_table_result clone() {
      return new create_table_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_table_result)
        return this.equals((create_table_result)that);
      return false;
    }

    public boolean equals(create_table_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_table_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class open_scanner_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_scanner_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)2);
    private static final TField RETRY_TABLE_NOT_FOUND_FIELD_DESC = new TField("retry_table_not_found", TType.BOOL, (short)3);

    public String name;
    public static final int NAME = 1;
    public ScanSpec scan_spec;
    public static final int SCAN_SPEC = 2;
    public boolean retry_table_not_found;
    public static final int RETRY_TABLE_NOT_FOUND = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean retry_table_not_found = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
      put(RETRY_TABLE_NOT_FOUND, new FieldMetaData("retry_table_not_found", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(open_scanner_args.class, metaDataMap);
    }

    public open_scanner_args() {
      this.retry_table_not_found = false;

    }

    public open_scanner_args(
      String name,
      ScanSpec scan_spec,
      boolean retry_table_not_found)
    {
      this();
      this.name = name;
      this.scan_spec = scan_spec;
      this.retry_table_not_found = retry_table_not_found;
      this.__isset.retry_table_not_found = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_scanner_args(open_scanner_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
      __isset.retry_table_not_found = other.__isset.retry_table_not_found;
      this.retry_table_not_found = other.retry_table_not_found;
    }

    @Override
    public open_scanner_args clone() {
      return new open_scanner_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public void setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    // Returns true if field scan_spec is set (has been asigned a value) and false otherwise
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public boolean isRetry_table_not_found() {
      return this.retry_table_not_found;
    }

    public void setRetry_table_not_found(boolean retry_table_not_found) {
      this.retry_table_not_found = retry_table_not_found;
      this.__isset.retry_table_not_found = true;
    }

    public void unsetRetry_table_not_found() {
      this.__isset.retry_table_not_found = false;
    }

    // Returns true if field retry_table_not_found is set (has been asigned a value) and false otherwise
    public boolean isSetRetry_table_not_found() {
      return this.__isset.retry_table_not_found;
    }

    public void setRetry_table_not_foundIsSet(boolean value) {
      this.__isset.retry_table_not_found = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      case RETRY_TABLE_NOT_FOUND:
        if (value == null) {
          unsetRetry_table_not_found();
        } else {
          setRetry_table_not_found((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case SCAN_SPEC:
        return getScan_spec();

      case RETRY_TABLE_NOT_FOUND:
        return new Boolean(isRetry_table_not_found());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case SCAN_SPEC:
        return isSetScan_spec();
      case RETRY_TABLE_NOT_FOUND:
        return isSetRetry_table_not_found();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_scanner_args)
        return this.equals((open_scanner_args)that);
      return false;
    }

    public boolean equals(open_scanner_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      boolean this_present_retry_table_not_found = true;
      boolean that_present_retry_table_not_found = true;
      if (this_present_retry_table_not_found || that_present_retry_table_not_found) {
        if (!(this_present_retry_table_not_found && that_present_retry_table_not_found))
          return false;
        if (this.retry_table_not_found != that.retry_table_not_found)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SCAN_SPEC:
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case RETRY_TABLE_NOT_FOUND:
            if (field.type == TType.BOOL) {
              this.retry_table_not_found = iprot.readBool();
              this.__isset.retry_table_not_found = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(RETRY_TABLE_NOT_FOUND_FIELD_DESC);
      oprot.writeBool(this.retry_table_not_found);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_scanner_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("retry_table_not_found:");
      sb.append(this.retry_table_not_found);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class open_scanner_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_scanner_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(open_scanner_result.class, metaDataMap);
    }

    public open_scanner_result() {
    }

    public open_scanner_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_scanner_result(open_scanner_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public open_scanner_result clone() {
      return new open_scanner_result(this);
    }

    public long getSuccess() {
      return this.success;
    }

    public void setSuccess(long success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_scanner_result)
        return this.equals((open_scanner_result)that);
      return false;
    }

    public boolean equals(open_scanner_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_scanner_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class close_scanner_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_scanner_args");
    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;
    public static final int SCANNER = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean scanner = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(close_scanner_args.class, metaDataMap);
    }

    public close_scanner_args() {
    }

    public close_scanner_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_scanner_args(close_scanner_args other) {
      __isset.scanner = other.__isset.scanner;
      this.scanner = other.scanner;
    }

    @Override
    public close_scanner_args clone() {
      return new close_scanner_args(this);
    }

    public long getScanner() {
      return this.scanner;
    }

    public void setScanner(long scanner) {
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    public void unsetScanner() {
      this.__isset.scanner = false;
    }

    // Returns true if field scanner is set (has been asigned a value) and false otherwise
    public boolean isSetScanner() {
      return this.__isset.scanner;
    }

    public void setScannerIsSet(boolean value) {
      this.__isset.scanner = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return new Long(getScanner());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return isSetScanner();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_scanner_args)
        return this.equals((close_scanner_args)that);
      return false;
    }

    public boolean equals(close_scanner_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SCANNER:
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              this.__isset.scanner = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_scanner_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class close_scanner_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_scanner_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(close_scanner_result.class, metaDataMap);
    }

    public close_scanner_result() {
    }

    public close_scanner_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_scanner_result(close_scanner_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public close_scanner_result clone() {
      return new close_scanner_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_scanner_result)
        return this.equals((close_scanner_result)that);
      return false;
    }

    public boolean equals(close_scanner_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_scanner_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_cells_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_args");
    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;
    public static final int SCANNER = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean scanner = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_cells_args.class, metaDataMap);
    }

    public next_cells_args() {
    }

    public next_cells_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_args(next_cells_args other) {
      __isset.scanner = other.__isset.scanner;
      this.scanner = other.scanner;
    }

    @Override
    public next_cells_args clone() {
      return new next_cells_args(this);
    }

    public long getScanner() {
      return this.scanner;
    }

    public void setScanner(long scanner) {
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    public void unsetScanner() {
      this.__isset.scanner = false;
    }

    // Returns true if field scanner is set (has been asigned a value) and false otherwise
    public boolean isSetScanner() {
      return this.__isset.scanner;
    }

    public void setScannerIsSet(boolean value) {
      this.__isset.scanner = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return new Long(getScanner());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return isSetScanner();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_args)
        return this.equals((next_cells_args)that);
      return false;
    }

    public boolean equals(next_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SCANNER:
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              this.__isset.scanner = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_cells_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_cells_result.class, metaDataMap);
    }

    public next_cells_result() {
    }

    public next_cells_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_result(next_cells_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public next_cells_result clone() {
      return new next_cells_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Cell> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_result)
        return this.equals((next_cells_result)that);
      return false;
    }

    public boolean equals(next_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list12 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list12.size);
                for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                {
                  Cell _elem14;
                  _elem14 = new Cell();
                  _elem14.read(iprot);
                  this.success.add(_elem14);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter15 : this.success)          {
            _iter15.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_cells_as_arrays_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_as_arrays_args");
    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;
    public static final int SCANNER = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean scanner = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_cells_as_arrays_args.class, metaDataMap);
    }

    public next_cells_as_arrays_args() {
    }

    public next_cells_as_arrays_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_as_arrays_args(next_cells_as_arrays_args other) {
      __isset.scanner = other.__isset.scanner;
      this.scanner = other.scanner;
    }

    @Override
    public next_cells_as_arrays_args clone() {
      return new next_cells_as_arrays_args(this);
    }

    public long getScanner() {
      return this.scanner;
    }

    public void setScanner(long scanner) {
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    public void unsetScanner() {
      this.__isset.scanner = false;
    }

    // Returns true if field scanner is set (has been asigned a value) and false otherwise
    public boolean isSetScanner() {
      return this.__isset.scanner;
    }

    public void setScannerIsSet(boolean value) {
      this.__isset.scanner = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return new Long(getScanner());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return isSetScanner();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_as_arrays_args)
        return this.equals((next_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(next_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SCANNER:
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              this.__isset.scanner = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_as_arrays_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_cells_as_arrays_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_as_arrays_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_cells_as_arrays_result.class, metaDataMap);
    }

    public next_cells_as_arrays_result() {
    }

    public next_cells_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_as_arrays_result(next_cells_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public next_cells_as_arrays_result clone() {
      return new next_cells_as_arrays_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<List<String>> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_as_arrays_result)
        return this.equals((next_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(next_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list16 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  List<String> _elem18;
                  {
                    TList _list19 = iprot.readListBegin();
                    _elem18 = new ArrayList<String>(_list19.size);
                    for (int _i20 = 0; _i20 < _list19.size; ++_i20)
                    {
                      String _elem21;
                      _elem21 = iprot.readString();
                      _elem18.add(_elem21);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem18);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter22 : this.success)          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter22.size()));
              for (String _iter23 : _iter22)              {
                oprot.writeString(_iter23);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_row_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_args");
    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;
    public static final int SCANNER = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean scanner = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_row_args.class, metaDataMap);
    }

    public next_row_args() {
    }

    public next_row_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_args(next_row_args other) {
      __isset.scanner = other.__isset.scanner;
      this.scanner = other.scanner;
    }

    @Override
    public next_row_args clone() {
      return new next_row_args(this);
    }

    public long getScanner() {
      return this.scanner;
    }

    public void setScanner(long scanner) {
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    public void unsetScanner() {
      this.__isset.scanner = false;
    }

    // Returns true if field scanner is set (has been asigned a value) and false otherwise
    public boolean isSetScanner() {
      return this.__isset.scanner;
    }

    public void setScannerIsSet(boolean value) {
      this.__isset.scanner = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return new Long(getScanner());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return isSetScanner();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_args)
        return this.equals((next_row_args)that);
      return false;
    }

    public boolean equals(next_row_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SCANNER:
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              this.__isset.scanner = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_row_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_row_result.class, metaDataMap);
    }

    public next_row_result() {
    }

    public next_row_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_result(next_row_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public next_row_result clone() {
      return new next_row_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Cell> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_result)
        return this.equals((next_row_result)that);
      return false;
    }

    public boolean equals(next_row_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list24 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list24.size);
                for (int _i25 = 0; _i25 < _list24.size; ++_i25)
                {
                  Cell _elem26;
                  _elem26 = new Cell();
                  _elem26.read(iprot);
                  this.success.add(_elem26);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter27 : this.success)          {
            _iter27.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_row_as_arrays_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_as_arrays_args");
    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;
    public static final int SCANNER = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean scanner = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_row_as_arrays_args.class, metaDataMap);
    }

    public next_row_as_arrays_args() {
    }

    public next_row_as_arrays_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_as_arrays_args(next_row_as_arrays_args other) {
      __isset.scanner = other.__isset.scanner;
      this.scanner = other.scanner;
    }

    @Override
    public next_row_as_arrays_args clone() {
      return new next_row_as_arrays_args(this);
    }

    public long getScanner() {
      return this.scanner;
    }

    public void setScanner(long scanner) {
      this.scanner = scanner;
      this.__isset.scanner = true;
    }

    public void unsetScanner() {
      this.__isset.scanner = false;
    }

    // Returns true if field scanner is set (has been asigned a value) and false otherwise
    public boolean isSetScanner() {
      return this.__isset.scanner;
    }

    public void setScannerIsSet(boolean value) {
      this.__isset.scanner = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return new Long(getScanner());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SCANNER:
        return isSetScanner();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_as_arrays_args)
        return this.equals((next_row_as_arrays_args)that);
      return false;
    }

    public boolean equals(next_row_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SCANNER:
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              this.__isset.scanner = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_as_arrays_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class next_row_as_arrays_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_as_arrays_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(next_row_as_arrays_result.class, metaDataMap);
    }

    public next_row_as_arrays_result() {
    }

    public next_row_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_as_arrays_result(next_row_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public next_row_as_arrays_result clone() {
      return new next_row_as_arrays_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<List<String>> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_as_arrays_result)
        return this.equals((next_row_as_arrays_result)that);
      return false;
    }

    public boolean equals(next_row_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list28 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list28.size);
                for (int _i29 = 0; _i29 < _list28.size; ++_i29)
                {
                  List<String> _elem30;
                  {
                    TList _list31 = iprot.readListBegin();
                    _elem30 = new ArrayList<String>(_list31.size);
                    for (int _i32 = 0; _i32 < _list31.size; ++_i32)
                    {
                      String _elem33;
                      _elem33 = iprot.readString();
                      _elem30.add(_elem33);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem30);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter34 : this.success)          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter34.size()));
              for (String _iter35 : _iter34)              {
                oprot.writeString(_iter35);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_row_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);

    public String name;
    public static final int NAME = 1;
    public String row;
    public static final int ROW = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_row_args.class, metaDataMap);
    }

    public get_row_args() {
    }

    public get_row_args(
      String name,
      String row)
    {
      this();
      this.name = name;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_args(get_row_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    @Override
    public get_row_args clone() {
      return new get_row_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public void setRow(String row) {
      this.row = row;
    }

    public void unsetRow() {
      this.row = null;
    }

    // Returns true if field row is set (has been asigned a value) and false otherwise
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case ROW:
        return getRow();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case ROW:
        return isSetRow();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_args)
        return this.equals((get_row_args)that);
      return false;
    }

    public boolean equals(get_row_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ROW:
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_row_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_row_result.class, metaDataMap);
    }

    public get_row_result() {
    }

    public get_row_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_result(get_row_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_row_result clone() {
      return new get_row_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Cell> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_result)
        return this.equals((get_row_result)that);
      return false;
    }

    public boolean equals(get_row_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list36 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list36.size);
                for (int _i37 = 0; _i37 < _list36.size; ++_i37)
                {
                  Cell _elem38;
                  _elem38 = new Cell();
                  _elem38.read(iprot);
                  this.success.add(_elem38);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter39 : this.success)          {
            _iter39.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_row_as_arrays_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_as_arrays_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);

    public String name;
    public static final int NAME = 1;
    public String row;
    public static final int ROW = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_row_as_arrays_args.class, metaDataMap);
    }

    public get_row_as_arrays_args() {
    }

    public get_row_as_arrays_args(
      String name,
      String row)
    {
      this();
      this.name = name;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_as_arrays_args(get_row_as_arrays_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    @Override
    public get_row_as_arrays_args clone() {
      return new get_row_as_arrays_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public void setRow(String row) {
      this.row = row;
    }

    public void unsetRow() {
      this.row = null;
    }

    // Returns true if field row is set (has been asigned a value) and false otherwise
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case ROW:
        return getRow();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case ROW:
        return isSetRow();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_as_arrays_args)
        return this.equals((get_row_as_arrays_args)that);
      return false;
    }

    public boolean equals(get_row_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ROW:
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_as_arrays_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_row_as_arrays_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_as_arrays_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_row_as_arrays_result.class, metaDataMap);
    }

    public get_row_as_arrays_result() {
    }

    public get_row_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_as_arrays_result(get_row_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_row_as_arrays_result clone() {
      return new get_row_as_arrays_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<List<String>> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_as_arrays_result)
        return this.equals((get_row_as_arrays_result)that);
      return false;
    }

    public boolean equals(get_row_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list40 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list40.size);
                for (int _i41 = 0; _i41 < _list40.size; ++_i41)
                {
                  List<String> _elem42;
                  {
                    TList _list43 = iprot.readListBegin();
                    _elem42 = new ArrayList<String>(_list43.size);
                    for (int _i44 = 0; _i44 < _list43.size; ++_i44)
                    {
                      String _elem45;
                      _elem45 = iprot.readString();
                      _elem42.add(_elem45);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem42);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter46 : this.success)          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter46.size()));
              for (String _iter47 : _iter46)              {
                oprot.writeString(_iter47);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_cell_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cell_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)2);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)3);

    public String name;
    public static final int NAME = 1;
    public String row;
    public static final int ROW = 2;
    public String column;
    public static final int COLUMN = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_cell_args.class, metaDataMap);
    }

    public get_cell_args() {
    }

    public get_cell_args(
      String name,
      String row,
      String column)
    {
      this();
      this.name = name;
      this.row = row;
      this.column = column;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cell_args(get_cell_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
    }

    @Override
    public get_cell_args clone() {
      return new get_cell_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public void setRow(String row) {
      this.row = row;
    }

    public void unsetRow() {
      this.row = null;
    }

    // Returns true if field row is set (has been asigned a value) and false otherwise
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public String getColumn() {
      return this.column;
    }

    public void setColumn(String column) {
      this.column = column;
    }

    public void unsetColumn() {
      this.column = null;
    }

    // Returns true if field column is set (has been asigned a value) and false otherwise
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cell_args)
        return this.equals((get_cell_args)that);
      return false;
    }

    public boolean equals(get_cell_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ROW:
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN:
            if (field.type == TType.STRING) {
              this.column = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeString(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cell_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_cell_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cell_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public byte[] success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_cell_result.class, metaDataMap);
    }

    public get_cell_result() {
    }

    public get_cell_result(
      byte[] success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cell_result(get_cell_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_cell_result clone() {
      return new get_cell_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public void setSuccess(byte[] success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cell_result)
        return this.equals((get_cell_result)that);
      return false;
    }

    public boolean equals(get_cell_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cell_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_cells_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)2);

    public String name;
    public static final int NAME = 1;
    public ScanSpec scan_spec;
    public static final int SCAN_SPEC = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_cells_args.class, metaDataMap);
    }

    public get_cells_args() {
    }

    public get_cells_args(
      String name,
      ScanSpec scan_spec)
    {
      this();
      this.name = name;
      this.scan_spec = scan_spec;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_args(get_cells_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
    }

    @Override
    public get_cells_args clone() {
      return new get_cells_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public void setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    // Returns true if field scan_spec is set (has been asigned a value) and false otherwise
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case SCAN_SPEC:
        return getScan_spec();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case SCAN_SPEC:
        return isSetScan_spec();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_args)
        return this.equals((get_cells_args)that);
      return false;
    }

    public boolean equals(get_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SCAN_SPEC:
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_cells_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_cells_result.class, metaDataMap);
    }

    public get_cells_result() {
    }

    public get_cells_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_result(get_cells_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_cells_result clone() {
      return new get_cells_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Cell> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_result)
        return this.equals((get_cells_result)that);
      return false;
    }

    public boolean equals(get_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list48 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list48.size);
                for (int _i49 = 0; _i49 < _list48.size; ++_i49)
                {
                  Cell _elem50;
                  _elem50 = new Cell();
                  _elem50.read(iprot);
                  this.success.add(_elem50);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter51 : this.success)          {
            _iter51.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_cells_as_arrays_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_as_arrays_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)2);

    public String name;
    public static final int NAME = 1;
    public ScanSpec scan_spec;
    public static final int SCAN_SPEC = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_cells_as_arrays_args.class, metaDataMap);
    }

    public get_cells_as_arrays_args() {
    }

    public get_cells_as_arrays_args(
      String name,
      ScanSpec scan_spec)
    {
      this();
      this.name = name;
      this.scan_spec = scan_spec;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_as_arrays_args(get_cells_as_arrays_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
    }

    @Override
    public get_cells_as_arrays_args clone() {
      return new get_cells_as_arrays_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public void setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    // Returns true if field scan_spec is set (has been asigned a value) and false otherwise
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case SCAN_SPEC:
        return getScan_spec();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case SCAN_SPEC:
        return isSetScan_spec();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_as_arrays_args)
        return this.equals((get_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(get_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SCAN_SPEC:
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_as_arrays_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_cells_as_arrays_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_as_arrays_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_cells_as_arrays_result.class, metaDataMap);
    }

    public get_cells_as_arrays_result() {
    }

    public get_cells_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_as_arrays_result(get_cells_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_cells_as_arrays_result clone() {
      return new get_cells_as_arrays_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<List<String>> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_as_arrays_result)
        return this.equals((get_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(get_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list52 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list52.size);
                for (int _i53 = 0; _i53 < _list52.size; ++_i53)
                {
                  List<String> _elem54;
                  {
                    TList _list55 = iprot.readListBegin();
                    _elem54 = new ArrayList<String>(_list55.size);
                    for (int _i56 = 0; _i56 < _list55.size; ++_i56)
                    {
                      String _elem57;
                      _elem57 = iprot.readString();
                      _elem54.add(_elem57);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem54);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter58 : this.success)          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter58.size()));
              for (String _iter59 : _iter58)              {
                oprot.writeString(_iter59);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class open_mutator_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_mutator_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField FLAGS_FIELD_DESC = new TField("flags", TType.I32, (short)2);
    private static final TField FLUSH_INTERVAL_FIELD_DESC = new TField("flush_interval", TType.I32, (short)3);

    public String name;
    public static final int NAME = 1;
    public int flags;
    public static final int FLAGS = 2;
    public int flush_interval;
    public static final int FLUSH_INTERVAL = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean flags = false;
      public boolean flush_interval = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(FLAGS, new FieldMetaData("flags", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(FLUSH_INTERVAL, new FieldMetaData("flush_interval", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(open_mutator_args.class, metaDataMap);
    }

    public open_mutator_args() {
      this.flags = 0;

      this.flush_interval = 0;

    }

    public open_mutator_args(
      String name,
      int flags,
      int flush_interval)
    {
      this();
      this.name = name;
      this.flags = flags;
      this.__isset.flags = true;
      this.flush_interval = flush_interval;
      this.__isset.flush_interval = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_mutator_args(open_mutator_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      __isset.flags = other.__isset.flags;
      this.flags = other.flags;
      __isset.flush_interval = other.__isset.flush_interval;
      this.flush_interval = other.flush_interval;
    }

    @Override
    public open_mutator_args clone() {
      return new open_mutator_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public int getFlags() {
      return this.flags;
    }

    public void setFlags(int flags) {
      this.flags = flags;
      this.__isset.flags = true;
    }

    public void unsetFlags() {
      this.__isset.flags = false;
    }

    // Returns true if field flags is set (has been asigned a value) and false otherwise
    public boolean isSetFlags() {
      return this.__isset.flags;
    }

    public void setFlagsIsSet(boolean value) {
      this.__isset.flags = value;
    }

    public int getFlush_interval() {
      return this.flush_interval;
    }

    public void setFlush_interval(int flush_interval) {
      this.flush_interval = flush_interval;
      this.__isset.flush_interval = true;
    }

    public void unsetFlush_interval() {
      this.__isset.flush_interval = false;
    }

    // Returns true if field flush_interval is set (has been asigned a value) and false otherwise
    public boolean isSetFlush_interval() {
      return this.__isset.flush_interval;
    }

    public void setFlush_intervalIsSet(boolean value) {
      this.__isset.flush_interval = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case FLAGS:
        if (value == null) {
          unsetFlags();
        } else {
          setFlags((Integer)value);
        }
        break;

      case FLUSH_INTERVAL:
        if (value == null) {
          unsetFlush_interval();
        } else {
          setFlush_interval((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case FLAGS:
        return new Integer(getFlags());

      case FLUSH_INTERVAL:
        return new Integer(getFlush_interval());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case FLAGS:
        return isSetFlags();
      case FLUSH_INTERVAL:
        return isSetFlush_interval();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_mutator_args)
        return this.equals((open_mutator_args)that);
      return false;
    }

    public boolean equals(open_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_flags = true;
      boolean that_present_flags = true;
      if (this_present_flags || that_present_flags) {
        if (!(this_present_flags && that_present_flags))
          return false;
        if (this.flags != that.flags)
          return false;
      }

      boolean this_present_flush_interval = true;
      boolean that_present_flush_interval = true;
      if (this_present_flush_interval || that_present_flush_interval) {
        if (!(this_present_flush_interval && that_present_flush_interval))
          return false;
        if (this.flush_interval != that.flush_interval)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FLAGS:
            if (field.type == TType.I32) {
              this.flags = iprot.readI32();
              this.__isset.flags = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FLUSH_INTERVAL:
            if (field.type == TType.I32) {
              this.flush_interval = iprot.readI32();
              this.__isset.flush_interval = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(FLAGS_FIELD_DESC);
      oprot.writeI32(this.flags);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(FLUSH_INTERVAL_FIELD_DESC);
      oprot.writeI32(this.flush_interval);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_mutator_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("flags:");
      sb.append(this.flags);
      first = false;
      if (!first) sb.append(", ");
      sb.append("flush_interval:");
      sb.append(this.flush_interval);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class open_mutator_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_mutator_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(open_mutator_result.class, metaDataMap);
    }

    public open_mutator_result() {
    }

    public open_mutator_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_mutator_result(open_mutator_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public open_mutator_result clone() {
      return new open_mutator_result(this);
    }

    public long getSuccess() {
      return this.success;
    }

    public void setSuccess(long success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_mutator_result)
        return this.equals((open_mutator_result)that);
      return false;
    }

    public boolean equals(open_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_mutator_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class close_mutator_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_mutator_args");
    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField FLUSH_FIELD_DESC = new TField("flush", TType.BOOL, (short)2);

    public long mutator;
    public static final int MUTATOR = 1;
    public boolean flush;
    public static final int FLUSH = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mutator = false;
      public boolean flush = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(FLUSH, new FieldMetaData("flush", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(close_mutator_args.class, metaDataMap);
    }

    public close_mutator_args() {
      this.flush = true;

    }

    public close_mutator_args(
      long mutator,
      boolean flush)
    {
      this();
      this.mutator = mutator;
      this.__isset.mutator = true;
      this.flush = flush;
      this.__isset.flush = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_mutator_args(close_mutator_args other) {
      __isset.mutator = other.__isset.mutator;
      this.mutator = other.mutator;
      __isset.flush = other.__isset.flush;
      this.flush = other.flush;
    }

    @Override
    public close_mutator_args clone() {
      return new close_mutator_args(this);
    }

    public long getMutator() {
      return this.mutator;
    }

    public void setMutator(long mutator) {
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    public void unsetMutator() {
      this.__isset.mutator = false;
    }

    // Returns true if field mutator is set (has been asigned a value) and false otherwise
    public boolean isSetMutator() {
      return this.__isset.mutator;
    }

    public void setMutatorIsSet(boolean value) {
      this.__isset.mutator = value;
    }

    public boolean isFlush() {
      return this.flush;
    }

    public void setFlush(boolean flush) {
      this.flush = flush;
      this.__isset.flush = true;
    }

    public void unsetFlush() {
      this.__isset.flush = false;
    }

    // Returns true if field flush is set (has been asigned a value) and false otherwise
    public boolean isSetFlush() {
      return this.__isset.flush;
    }

    public void setFlushIsSet(boolean value) {
      this.__isset.flush = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case FLUSH:
        if (value == null) {
          unsetFlush();
        } else {
          setFlush((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return new Long(getMutator());

      case FLUSH:
        return new Boolean(isFlush());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return isSetMutator();
      case FLUSH:
        return isSetFlush();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_mutator_args)
        return this.equals((close_mutator_args)that);
      return false;
    }

    public boolean equals(close_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_flush = true;
      boolean that_present_flush = true;
      if (this_present_flush || that_present_flush) {
        if (!(this_present_flush && that_present_flush))
          return false;
        if (this.flush != that.flush)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case MUTATOR:
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              this.__isset.mutator = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FLUSH:
            if (field.type == TType.BOOL) {
              this.flush = iprot.readBool();
              this.__isset.flush = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(FLUSH_FIELD_DESC);
      oprot.writeBool(this.flush);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_mutator_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("flush:");
      sb.append(this.flush);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class close_mutator_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_mutator_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(close_mutator_result.class, metaDataMap);
    }

    public close_mutator_result() {
    }

    public close_mutator_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_mutator_result(close_mutator_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public close_mutator_result clone() {
      return new close_mutator_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_mutator_result)
        return this.equals((close_mutator_result)that);
      return false;
    }

    public boolean equals(close_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_mutator_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cell_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_args");
    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELL_FIELD_DESC = new TField("cell", TType.STRUCT, (short)2);

    public long mutator;
    public static final int MUTATOR = 1;
    public Cell cell;
    public static final int CELL = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mutator = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(CELL, new FieldMetaData("cell", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Cell.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cell_args.class, metaDataMap);
    }

    public set_cell_args() {
    }

    public set_cell_args(
      long mutator,
      Cell cell)
    {
      this();
      this.mutator = mutator;
      this.__isset.mutator = true;
      this.cell = cell;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_args(set_cell_args other) {
      __isset.mutator = other.__isset.mutator;
      this.mutator = other.mutator;
      if (other.isSetCell()) {
        this.cell = new Cell(other.cell);
      }
    }

    @Override
    public set_cell_args clone() {
      return new set_cell_args(this);
    }

    public long getMutator() {
      return this.mutator;
    }

    public void setMutator(long mutator) {
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    public void unsetMutator() {
      this.__isset.mutator = false;
    }

    // Returns true if field mutator is set (has been asigned a value) and false otherwise
    public boolean isSetMutator() {
      return this.__isset.mutator;
    }

    public void setMutatorIsSet(boolean value) {
      this.__isset.mutator = value;
    }

    public Cell getCell() {
      return this.cell;
    }

    public void setCell(Cell cell) {
      this.cell = cell;
    }

    public void unsetCell() {
      this.cell = null;
    }

    // Returns true if field cell is set (has been asigned a value) and false otherwise
    public boolean isSetCell() {
      return this.cell != null;
    }

    public void setCellIsSet(boolean value) {
      if (!value) {
        this.cell = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELL:
        if (value == null) {
          unsetCell();
        } else {
          setCell((Cell)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return new Long(getMutator());

      case CELL:
        return getCell();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return isSetMutator();
      case CELL:
        return isSetCell();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_args)
        return this.equals((set_cell_args)that);
      return false;
    }

    public boolean equals(set_cell_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cell = true && this.isSetCell();
      boolean that_present_cell = true && that.isSetCell();
      if (this_present_cell || that_present_cell) {
        if (!(this_present_cell && that_present_cell))
          return false;
        if (!this.cell.equals(that.cell))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case MUTATOR:
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              this.__isset.mutator = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CELL:
            if (field.type == TType.STRUCT) {
              this.cell = new Cell();
              this.cell.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cell != null) {
        oprot.writeFieldBegin(CELL_FIELD_DESC);
        this.cell.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cell:");
      if (this.cell == null) {
        sb.append("null");
      } else {
        sb.append(this.cell);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cell_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cell_result.class, metaDataMap);
    }

    public set_cell_result() {
    }

    public set_cell_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_result(set_cell_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public set_cell_result clone() {
      return new set_cell_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_result)
        return this.equals((set_cell_result)that);
      return false;
    }

    public boolean equals(set_cell_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cell_as_array_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_as_array_args");
    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELL_FIELD_DESC = new TField("cell", TType.LIST, (short)2);

    public long mutator;
    public static final int MUTATOR = 1;
    public List<String> cell;
    public static final int CELL = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mutator = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(CELL, new FieldMetaData("cell", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cell_as_array_args.class, metaDataMap);
    }

    public set_cell_as_array_args() {
    }

    public set_cell_as_array_args(
      long mutator,
      List<String> cell)
    {
      this();
      this.mutator = mutator;
      this.__isset.mutator = true;
      this.cell = cell;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_as_array_args(set_cell_as_array_args other) {
      __isset.mutator = other.__isset.mutator;
      this.mutator = other.mutator;
      if (other.isSetCell()) {
        this.cell = other.cell;
      }
    }

    @Override
    public set_cell_as_array_args clone() {
      return new set_cell_as_array_args(this);
    }

    public long getMutator() {
      return this.mutator;
    }

    public void setMutator(long mutator) {
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    public void unsetMutator() {
      this.__isset.mutator = false;
    }

    // Returns true if field mutator is set (has been asigned a value) and false otherwise
    public boolean isSetMutator() {
      return this.__isset.mutator;
    }

    public void setMutatorIsSet(boolean value) {
      this.__isset.mutator = value;
    }

    public int getCellSize() {
      return (this.cell == null) ? 0 : this.cell.size();
    }

    public java.util.Iterator<String> getCellIterator() {
      return (this.cell == null) ? null : this.cell.iterator();
    }

    public void addToCell(String elem) {
      if (this.cell == null) {
        this.cell = new ArrayList<String>();
      }
      this.cell.add(elem);
    }

    public List<String> getCell() {
      return this.cell;
    }

    public void setCell(List<String> cell) {
      this.cell = cell;
    }

    public void unsetCell() {
      this.cell = null;
    }

    // Returns true if field cell is set (has been asigned a value) and false otherwise
    public boolean isSetCell() {
      return this.cell != null;
    }

    public void setCellIsSet(boolean value) {
      if (!value) {
        this.cell = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELL:
        if (value == null) {
          unsetCell();
        } else {
          setCell((List<String>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return new Long(getMutator());

      case CELL:
        return getCell();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return isSetMutator();
      case CELL:
        return isSetCell();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_as_array_args)
        return this.equals((set_cell_as_array_args)that);
      return false;
    }

    public boolean equals(set_cell_as_array_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cell = true && this.isSetCell();
      boolean that_present_cell = true && that.isSetCell();
      if (this_present_cell || that_present_cell) {
        if (!(this_present_cell && that_present_cell))
          return false;
        if (!this.cell.equals(that.cell))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case MUTATOR:
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              this.__isset.mutator = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CELL:
            if (field.type == TType.LIST) {
              {
                TList _list60 = iprot.readListBegin();
                this.cell = new ArrayList<String>(_list60.size);
                for (int _i61 = 0; _i61 < _list60.size; ++_i61)
                {
                  String _elem62;
                  _elem62 = iprot.readString();
                  this.cell.add(_elem62);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cell != null) {
        oprot.writeFieldBegin(CELL_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.cell.size()));
          for (String _iter63 : this.cell)          {
            oprot.writeString(_iter63);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_as_array_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cell:");
      if (this.cell == null) {
        sb.append("null");
      } else {
        sb.append(this.cell);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cell_as_array_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_as_array_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cell_as_array_result.class, metaDataMap);
    }

    public set_cell_as_array_result() {
    }

    public set_cell_as_array_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_as_array_result(set_cell_as_array_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public set_cell_as_array_result clone() {
      return new set_cell_as_array_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_as_array_result)
        return this.equals((set_cell_as_array_result)that);
      return false;
    }

    public boolean equals(set_cell_as_array_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_as_array_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cells_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_args");
    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.LIST, (short)2);

    public long mutator;
    public static final int MUTATOR = 1;
    public List<Cell> cells;
    public static final int CELLS = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mutator = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cells_args.class, metaDataMap);
    }

    public set_cells_args() {
    }

    public set_cells_args(
      long mutator,
      List<Cell> cells)
    {
      this();
      this.mutator = mutator;
      this.__isset.mutator = true;
      this.cells = cells;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_args(set_cells_args other) {
      __isset.mutator = other.__isset.mutator;
      this.mutator = other.mutator;
      if (other.isSetCells()) {
        List<Cell> __this__cells = new ArrayList<Cell>();
        for (Cell other_element : other.cells) {
          __this__cells.add(new Cell(other_element));
        }
        this.cells = __this__cells;
      }
    }

    @Override
    public set_cells_args clone() {
      return new set_cells_args(this);
    }

    public long getMutator() {
      return this.mutator;
    }

    public void setMutator(long mutator) {
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    public void unsetMutator() {
      this.__isset.mutator = false;
    }

    // Returns true if field mutator is set (has been asigned a value) and false otherwise
    public boolean isSetMutator() {
      return this.__isset.mutator;
    }

    public void setMutatorIsSet(boolean value) {
      this.__isset.mutator = value;
    }

    public int getCellsSize() {
      return (this.cells == null) ? 0 : this.cells.size();
    }

    public java.util.Iterator<Cell> getCellsIterator() {
      return (this.cells == null) ? null : this.cells.iterator();
    }

    public void addToCells(Cell elem) {
      if (this.cells == null) {
        this.cells = new ArrayList<Cell>();
      }
      this.cells.add(elem);
    }

    public List<Cell> getCells() {
      return this.cells;
    }

    public void setCells(List<Cell> cells) {
      this.cells = cells;
    }

    public void unsetCells() {
      this.cells = null;
    }

    // Returns true if field cells is set (has been asigned a value) and false otherwise
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((List<Cell>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return new Long(getMutator());

      case CELLS:
        return getCells();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return isSetMutator();
      case CELLS:
        return isSetCells();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_args)
        return this.equals((set_cells_args)that);
      return false;
    }

    public boolean equals(set_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case MUTATOR:
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              this.__isset.mutator = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CELLS:
            if (field.type == TType.LIST) {
              {
                TList _list64 = iprot.readListBegin();
                this.cells = new ArrayList<Cell>(_list64.size);
                for (int _i65 = 0; _i65 < _list64.size; ++_i65)
                {
                  Cell _elem66;
                  _elem66 = new Cell();
                  _elem66.read(iprot);
                  this.cells.add(_elem66);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.cells.size()));
          for (Cell _iter67 : this.cells)          {
            _iter67.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cells_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cells_result.class, metaDataMap);
    }

    public set_cells_result() {
    }

    public set_cells_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_result(set_cells_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public set_cells_result clone() {
      return new set_cells_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_result)
        return this.equals((set_cells_result)that);
      return false;
    }

    public boolean equals(set_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cells_as_arrays_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_as_arrays_args");
    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.LIST, (short)2);

    public long mutator;
    public static final int MUTATOR = 1;
    public List<List<String>> cells;
    public static final int CELLS = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mutator = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cells_as_arrays_args.class, metaDataMap);
    }

    public set_cells_as_arrays_args() {
    }

    public set_cells_as_arrays_args(
      long mutator,
      List<List<String>> cells)
    {
      this();
      this.mutator = mutator;
      this.__isset.mutator = true;
      this.cells = cells;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_as_arrays_args(set_cells_as_arrays_args other) {
      __isset.mutator = other.__isset.mutator;
      this.mutator = other.mutator;
      if (other.isSetCells()) {
        List<List<String>> __this__cells = new ArrayList<List<String>>();
        for (List<String> other_element : other.cells) {
          __this__cells.add(other_element);
        }
        this.cells = __this__cells;
      }
    }

    @Override
    public set_cells_as_arrays_args clone() {
      return new set_cells_as_arrays_args(this);
    }

    public long getMutator() {
      return this.mutator;
    }

    public void setMutator(long mutator) {
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    public void unsetMutator() {
      this.__isset.mutator = false;
    }

    // Returns true if field mutator is set (has been asigned a value) and false otherwise
    public boolean isSetMutator() {
      return this.__isset.mutator;
    }

    public void setMutatorIsSet(boolean value) {
      this.__isset.mutator = value;
    }

    public int getCellsSize() {
      return (this.cells == null) ? 0 : this.cells.size();
    }

    public java.util.Iterator<List<String>> getCellsIterator() {
      return (this.cells == null) ? null : this.cells.iterator();
    }

    public void addToCells(List<String> elem) {
      if (this.cells == null) {
        this.cells = new ArrayList<List<String>>();
      }
      this.cells.add(elem);
    }

    public List<List<String>> getCells() {
      return this.cells;
    }

    public void setCells(List<List<String>> cells) {
      this.cells = cells;
    }

    public void unsetCells() {
      this.cells = null;
    }

    // Returns true if field cells is set (has been asigned a value) and false otherwise
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((List<List<String>>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return new Long(getMutator());

      case CELLS:
        return getCells();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return isSetMutator();
      case CELLS:
        return isSetCells();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_as_arrays_args)
        return this.equals((set_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(set_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case MUTATOR:
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              this.__isset.mutator = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CELLS:
            if (field.type == TType.LIST) {
              {
                TList _list68 = iprot.readListBegin();
                this.cells = new ArrayList<List<String>>(_list68.size);
                for (int _i69 = 0; _i69 < _list68.size; ++_i69)
                {
                  List<String> _elem70;
                  {
                    TList _list71 = iprot.readListBegin();
                    _elem70 = new ArrayList<String>(_list71.size);
                    for (int _i72 = 0; _i72 < _list71.size; ++_i72)
                    {
                      String _elem73;
                      _elem73 = iprot.readString();
                      _elem70.add(_elem73);
                    }
                    iprot.readListEnd();
                  }
                  this.cells.add(_elem70);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.cells.size()));
          for (List<String> _iter74 : this.cells)          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter74.size()));
              for (String _iter75 : _iter74)              {
                oprot.writeString(_iter75);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_as_arrays_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class set_cells_as_arrays_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_as_arrays_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(set_cells_as_arrays_result.class, metaDataMap);
    }

    public set_cells_as_arrays_result() {
    }

    public set_cells_as_arrays_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_as_arrays_result(set_cells_as_arrays_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public set_cells_as_arrays_result clone() {
      return new set_cells_as_arrays_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_as_arrays_result)
        return this.equals((set_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(set_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_as_arrays_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class flush_mutator_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("flush_mutator_args");
    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);

    public long mutator;
    public static final int MUTATOR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mutator = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(flush_mutator_args.class, metaDataMap);
    }

    public flush_mutator_args() {
    }

    public flush_mutator_args(
      long mutator)
    {
      this();
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public flush_mutator_args(flush_mutator_args other) {
      __isset.mutator = other.__isset.mutator;
      this.mutator = other.mutator;
    }

    @Override
    public flush_mutator_args clone() {
      return new flush_mutator_args(this);
    }

    public long getMutator() {
      return this.mutator;
    }

    public void setMutator(long mutator) {
      this.mutator = mutator;
      this.__isset.mutator = true;
    }

    public void unsetMutator() {
      this.__isset.mutator = false;
    }

    // Returns true if field mutator is set (has been asigned a value) and false otherwise
    public boolean isSetMutator() {
      return this.__isset.mutator;
    }

    public void setMutatorIsSet(boolean value) {
      this.__isset.mutator = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return new Long(getMutator());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case MUTATOR:
        return isSetMutator();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof flush_mutator_args)
        return this.equals((flush_mutator_args)that);
      return false;
    }

    public boolean equals(flush_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case MUTATOR:
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              this.__isset.mutator = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("flush_mutator_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class flush_mutator_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("flush_mutator_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(flush_mutator_result.class, metaDataMap);
    }

    public flush_mutator_result() {
    }

    public flush_mutator_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public flush_mutator_result(flush_mutator_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public flush_mutator_result clone() {
      return new flush_mutator_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof flush_mutator_result)
        return this.equals((flush_mutator_result)that);
      return false;
    }

    public boolean equals(flush_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("flush_mutator_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_table_id_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_id_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);

    public String name;
    public static final int NAME = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_table_id_args.class, metaDataMap);
    }

    public get_table_id_args() {
    }

    public get_table_id_args(
      String name)
    {
      this();
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_id_args(get_table_id_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    @Override
    public get_table_id_args clone() {
      return new get_table_id_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_id_args)
        return this.equals((get_table_id_args)that);
      return false;
    }

    public boolean equals(get_table_id_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_id_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_table_id_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_id_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public int success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_table_id_result.class, metaDataMap);
    }

    public get_table_id_result() {
    }

    public get_table_id_result(
      int success,
      ClientException e)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_id_result(get_table_id_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_table_id_result clone() {
      return new get_table_id_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_id_result)
        return this.equals((get_table_id_result)that);
      return false;
    }

    public boolean equals(get_table_id_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_id_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_schema_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);

    public String name;
    public static final int NAME = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_schema_args.class, metaDataMap);
    }

    public get_schema_args() {
    }

    public get_schema_args(
      String name)
    {
      this();
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_args(get_schema_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    @Override
    public get_schema_args clone() {
      return new get_schema_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_args)
        return this.equals((get_schema_args)that);
      return false;
    }

    public boolean equals(get_schema_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_schema_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public String success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_schema_result.class, metaDataMap);
    }

    public get_schema_result() {
    }

    public get_schema_result(
      String success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_result(get_schema_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_schema_result clone() {
      return new get_schema_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_result)
        return this.equals((get_schema_result)that);
      return false;
    }

    public boolean equals(get_schema_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_tables_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_tables_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_tables_args.class, metaDataMap);
    }

    public get_tables_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_tables_args(get_tables_args other) {
    }

    @Override
    public get_tables_args clone() {
      return new get_tables_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_tables_args)
        return this.equals((get_tables_args)that);
      return false;
    }

    public boolean equals(get_tables_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_tables_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_tables_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_tables_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<String> success;
    public static final int SUCCESS = 0;
    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_tables_result.class, metaDataMap);
    }

    public get_tables_result() {
    }

    public get_tables_result(
      List<String> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_tables_result(get_tables_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public get_tables_result clone() {
      return new get_tables_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_tables_result)
        return this.equals((get_tables_result)that);
      return false;
    }

    public boolean equals(get_tables_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list76 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list76.size);
                for (int _i77 = 0; _i77 < _list76.size; ++_i77)
                {
                  String _elem78;
                  _elem78 = iprot.readString();
                  this.success.add(_elem78);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter79 : this.success)          {
            oprot.writeString(_iter79);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_tables_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class drop_table_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_table_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField IF_EXISTS_FIELD_DESC = new TField("if_exists", TType.BOOL, (short)2);

    public String name;
    public static final int NAME = 1;
    public boolean if_exists;
    public static final int IF_EXISTS = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean if_exists = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(IF_EXISTS, new FieldMetaData("if_exists", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(drop_table_args.class, metaDataMap);
    }

    public drop_table_args() {
      this.if_exists = true;

    }

    public drop_table_args(
      String name,
      boolean if_exists)
    {
      this();
      this.name = name;
      this.if_exists = if_exists;
      this.__isset.if_exists = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_table_args(drop_table_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      __isset.if_exists = other.__isset.if_exists;
      this.if_exists = other.if_exists;
    }

    @Override
    public drop_table_args clone() {
      return new drop_table_args(this);
    }

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public boolean isIf_exists() {
      return this.if_exists;
    }

    public void setIf_exists(boolean if_exists) {
      this.if_exists = if_exists;
      this.__isset.if_exists = true;
    }

    public void unsetIf_exists() {
      this.__isset.if_exists = false;
    }

    // Returns true if field if_exists is set (has been asigned a value) and false otherwise
    public boolean isSetIf_exists() {
      return this.__isset.if_exists;
    }

    public void setIf_existsIsSet(boolean value) {
      this.__isset.if_exists = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case IF_EXISTS:
        if (value == null) {
          unsetIf_exists();
        } else {
          setIf_exists((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case IF_EXISTS:
        return new Boolean(isIf_exists());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case IF_EXISTS:
        return isSetIf_exists();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_table_args)
        return this.equals((drop_table_args)that);
      return false;
    }

    public boolean equals(drop_table_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_if_exists = true;
      boolean that_present_if_exists = true;
      if (this_present_if_exists || that_present_if_exists) {
        if (!(this_present_if_exists && that_present_if_exists))
          return false;
        if (this.if_exists != that.if_exists)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IF_EXISTS:
            if (field.type == TType.BOOL) {
              this.if_exists = iprot.readBool();
              this.__isset.if_exists = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(IF_EXISTS_FIELD_DESC);
      oprot.writeBool(this.if_exists);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_table_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("if_exists:");
      sb.append(this.if_exists);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class drop_table_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_table_result");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(drop_table_result.class, metaDataMap);
    }

    public drop_table_result() {
    }

    public drop_table_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_table_result(drop_table_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    @Override
    public drop_table_result clone() {
      return new drop_table_result(this);
    }

    public ClientException getE() {
      return this.e;
    }

    public void setE(ClientException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_table_result)
        return this.equals((drop_table_result)that);
      return false;
    }

    public boolean equals(drop_table_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_table_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
