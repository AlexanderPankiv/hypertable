/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.hypertable.thriftgen;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import com.facebook.thrift.*;

import com.facebook.thrift.protocol.*;
import com.facebook.thrift.transport.*;

/**
 * Specifies options for a scan
 * 
 * <dl>
 *   <dt>row_intervals</dt>
 *   <dd>A list of ranges of rows to scan. Mutually exclusive with
 *   cell_interval</dd>
 * 
 *   <dt>cell_intervals</dt>
 *   <dd>A list of ranges of cells to scan. Mutually exclusive with
 *   row_intervals</dd>
 * 
 *   <dt>return_deletes</dt>
 *   <dd>Indicates whether cells pending delete are returned</dd>
 * 
 *   <dt>revs</dt>
 *   <dd>Specifies max number of revisions of cells to return</dd>
 * 
 *   <dt>row_limit</dt>
 *   <dd>Specifies max number of rows to return</dd>
 * 
 *   <dt>start_time</dt>
 *   <dd>Specifies start time in nanoseconds since epoch for cells to
 *   return</dd>
 * 
 *   <dt>end_time</dt>
 *   <dd>Specifies end time in nanoseconds since epoch for cells to return</dd>
 */
public class ScanSpec implements TBase, java.io.Serializable, Cloneable {
  public List<RowInterval> row_intervals;
  public static final int ROW_INTERVALS = 1;
  public List<CellInterval> cell_intervals;
  public static final int CELL_INTERVALS = 2;
  public boolean return_deletes;
  public static final int RETURN_DELETES = 3;
  public int revs;
  public static final int REVS = 4;
  public int row_limit;
  public static final int ROW_LIMIT = 5;
  public long start_time;
  public static final int START_TIME = 6;
  public long end_time;
  public static final int END_TIME = 7;

  public final Isset __isset = new Isset();
  public static final class Isset implements java.io.Serializable {
    public boolean row_intervals = false;
    public boolean cell_intervals = false;
    public boolean return_deletes = false;
    public boolean revs = false;
    public boolean row_limit = false;
    public boolean start_time = false;
    public boolean end_time = false;
  }

  public ScanSpec() {
    this.return_deletes = false;

    this.revs = 0;

    this.row_limit = 0;

  }

  public ScanSpec(
    List<RowInterval> row_intervals,
    List<CellInterval> cell_intervals,
    boolean return_deletes,
    int revs,
    int row_limit,
    long start_time,
    long end_time)
  {
    this();
    this.row_intervals = row_intervals;
    this.__isset.row_intervals = (row_intervals != null);
    this.cell_intervals = cell_intervals;
    this.__isset.cell_intervals = (cell_intervals != null);
    this.return_deletes = return_deletes;
    this.__isset.return_deletes = true;
    this.revs = revs;
    this.__isset.revs = true;
    this.row_limit = row_limit;
    this.__isset.row_limit = true;
    this.start_time = start_time;
    this.__isset.start_time = true;
    this.end_time = end_time;
    this.__isset.end_time = true;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public ScanSpec(ScanSpec other) {
    __isset.row_intervals = other.__isset.row_intervals;
    if (other.row_intervals != null) {
      List<RowInterval> __this__row_intervals = new ArrayList<RowInterval>();
      for (RowInterval other_element : other.row_intervals) {
        __this__row_intervals.add(new RowInterval(other_element));
      }
      this.row_intervals = __this__row_intervals;
    }
    __isset.cell_intervals = other.__isset.cell_intervals;
    if (other.cell_intervals != null) {
      List<CellInterval> __this__cell_intervals = new ArrayList<CellInterval>();
      for (CellInterval other_element : other.cell_intervals) {
        __this__cell_intervals.add(new CellInterval(other_element));
      }
      this.cell_intervals = __this__cell_intervals;
    }
    __isset.return_deletes = other.__isset.return_deletes;
    this.return_deletes = other.return_deletes;
    __isset.revs = other.__isset.revs;
    this.revs = other.revs;
    __isset.row_limit = other.__isset.row_limit;
    this.row_limit = other.row_limit;
    __isset.start_time = other.__isset.start_time;
    this.start_time = other.start_time;
    __isset.end_time = other.__isset.end_time;
    this.end_time = other.end_time;
  }

  public ScanSpec clone() {
    return new ScanSpec(this);
  }

  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof ScanSpec)
      return this.equals((ScanSpec)that);
    return false;
  }

  public boolean equals(ScanSpec that) {
    if (that == null)
      return false;

    boolean this_present_row_intervals = true && (this.__isset.row_intervals) && (this.row_intervals != null);
    boolean that_present_row_intervals = true && (that.__isset.row_intervals) && (that.row_intervals != null);
    if (this_present_row_intervals || that_present_row_intervals) {
      if (!(this_present_row_intervals && that_present_row_intervals))
        return false;
      if (!this.row_intervals.equals(that.row_intervals))
        return false;
    }

    boolean this_present_cell_intervals = true && (this.__isset.cell_intervals) && (this.cell_intervals != null);
    boolean that_present_cell_intervals = true && (that.__isset.cell_intervals) && (that.cell_intervals != null);
    if (this_present_cell_intervals || that_present_cell_intervals) {
      if (!(this_present_cell_intervals && that_present_cell_intervals))
        return false;
      if (!this.cell_intervals.equals(that.cell_intervals))
        return false;
    }

    boolean this_present_return_deletes = true && (this.__isset.return_deletes);
    boolean that_present_return_deletes = true && (that.__isset.return_deletes);
    if (this_present_return_deletes || that_present_return_deletes) {
      if (!(this_present_return_deletes && that_present_return_deletes))
        return false;
      if (this.return_deletes != that.return_deletes)
        return false;
    }

    boolean this_present_revs = true && (this.__isset.revs);
    boolean that_present_revs = true && (that.__isset.revs);
    if (this_present_revs || that_present_revs) {
      if (!(this_present_revs && that_present_revs))
        return false;
      if (this.revs != that.revs)
        return false;
    }

    boolean this_present_row_limit = true && (this.__isset.row_limit);
    boolean that_present_row_limit = true && (that.__isset.row_limit);
    if (this_present_row_limit || that_present_row_limit) {
      if (!(this_present_row_limit && that_present_row_limit))
        return false;
      if (this.row_limit != that.row_limit)
        return false;
    }

    boolean this_present_start_time = true && (this.__isset.start_time);
    boolean that_present_start_time = true && (that.__isset.start_time);
    if (this_present_start_time || that_present_start_time) {
      if (!(this_present_start_time && that_present_start_time))
        return false;
      if (this.start_time != that.start_time)
        return false;
    }

    boolean this_present_end_time = true && (this.__isset.end_time);
    boolean that_present_end_time = true && (that.__isset.end_time);
    if (this_present_end_time || that_present_end_time) {
      if (!(this_present_end_time && that_present_end_time))
        return false;
      if (this.end_time != that.end_time)
        return false;
    }

    return true;
  }

  public int hashCode() {
    return 0;
  }

  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ROW_INTERVALS:
          if (field.type == TType.LIST) {
            {
              TList _list0 = iprot.readListBegin();
              this.row_intervals = new ArrayList<RowInterval>(_list0.size);
              for (int _i1 = 0; _i1 < _list0.size; ++_i1)
              {
                RowInterval _elem2 = new RowInterval();
                _elem2 = new RowInterval();
                _elem2.read(iprot);
                this.row_intervals.add(_elem2);
              }
              iprot.readListEnd();
            }
            this.__isset.row_intervals = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CELL_INTERVALS:
          if (field.type == TType.LIST) {
            {
              TList _list3 = iprot.readListBegin();
              this.cell_intervals = new ArrayList<CellInterval>(_list3.size);
              for (int _i4 = 0; _i4 < _list3.size; ++_i4)
              {
                CellInterval _elem5 = new CellInterval();
                _elem5 = new CellInterval();
                _elem5.read(iprot);
                this.cell_intervals.add(_elem5);
              }
              iprot.readListEnd();
            }
            this.__isset.cell_intervals = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RETURN_DELETES:
          if (field.type == TType.BOOL) {
            this.return_deletes = iprot.readBool();
            this.__isset.return_deletes = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REVS:
          if (field.type == TType.I32) {
            this.revs = iprot.readI32();
            this.__isset.revs = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROW_LIMIT:
          if (field.type == TType.I32) {
            this.row_limit = iprot.readI32();
            this.__isset.row_limit = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case START_TIME:
          if (field.type == TType.I64) {
            this.start_time = iprot.readI64();
            this.__isset.start_time = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case END_TIME:
          if (field.type == TType.I64) {
            this.end_time = iprot.readI64();
            this.__isset.end_time = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields
  }

  public void write(TProtocol oprot) throws TException {


    TStruct struct = new TStruct("ScanSpec");
    oprot.writeStructBegin(struct);
    TField field = new TField();
    if (this.row_intervals != null) {
      field.name = "row_intervals";
      field.type = TType.LIST;
      field.id = ROW_INTERVALS;
      oprot.writeFieldBegin(field);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.row_intervals.size()));
        for (RowInterval _iter6 : this.row_intervals)        {
          _iter6.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.cell_intervals != null) {
      field.name = "cell_intervals";
      field.type = TType.LIST;
      field.id = CELL_INTERVALS;
      oprot.writeFieldBegin(field);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.cell_intervals.size()));
        for (CellInterval _iter7 : this.cell_intervals)        {
          _iter7.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    field.name = "return_deletes";
    field.type = TType.BOOL;
    field.id = RETURN_DELETES;
    oprot.writeFieldBegin(field);
    oprot.writeBool(this.return_deletes);
    oprot.writeFieldEnd();
    field.name = "revs";
    field.type = TType.I32;
    field.id = REVS;
    oprot.writeFieldBegin(field);
    oprot.writeI32(this.revs);
    oprot.writeFieldEnd();
    field.name = "row_limit";
    field.type = TType.I32;
    field.id = ROW_LIMIT;
    oprot.writeFieldBegin(field);
    oprot.writeI32(this.row_limit);
    oprot.writeFieldEnd();
    field.name = "start_time";
    field.type = TType.I64;
    field.id = START_TIME;
    oprot.writeFieldBegin(field);
    oprot.writeI64(this.start_time);
    oprot.writeFieldEnd();
    field.name = "end_time";
    field.type = TType.I64;
    field.id = END_TIME;
    oprot.writeFieldBegin(field);
    oprot.writeI64(this.end_time);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public String toString() {
    StringBuilder sb = new StringBuilder("ScanSpec(");
    boolean first = true;

    if (__isset.row_intervals) {
      if (!first) sb.append(", ");
      sb.append("row_intervals:");
      sb.append(this.row_intervals);
      first = false;
    }
    if (__isset.cell_intervals) {
      if (!first) sb.append(", ");
      sb.append("cell_intervals:");
      sb.append(this.cell_intervals);
      first = false;
    }
    if (__isset.return_deletes) {
      if (!first) sb.append(", ");
      sb.append("return_deletes:");
      sb.append(this.return_deletes);
      first = false;
    }
    if (__isset.revs) {
      if (!first) sb.append(", ");
      sb.append("revs:");
      sb.append(this.revs);
      first = false;
    }
    if (__isset.row_limit) {
      if (!first) sb.append(", ");
      sb.append("row_limit:");
      sb.append(this.row_limit);
      first = false;
    }
    if (__isset.start_time) {
      if (!first) sb.append(", ");
      sb.append("start_time:");
      sb.append(this.start_time);
      first = false;
    }
    if (__isset.end_time) {
      if (!first) sb.append(", ");
      sb.append("end_time:");
      sb.append(this.end_time);
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

}

