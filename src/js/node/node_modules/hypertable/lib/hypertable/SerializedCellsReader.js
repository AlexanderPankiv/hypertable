/*
 * Copyright (C) 2007-2015 Hypertable, Inc.
 *
 * This file is part of Hypertable.
 *
 * Hypertable is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 3
 * of the License.
 *
 * Hypertable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

'use strict';
var assert = require('assert');
var SerializedCellsFlag = require('./SerializedCellsFlag.js');
var SerializedCellsVersion = require('./SerializedCellsVersion.js');
var Timestamp = require('./Timestamp.js');
var Hypertable = require('./Client_types.js');

var flipBytes = function(buffer) {
  for (var i=0; i<buffer.length/2; i++) {
    var tmp = buffer[buffer.length-i-1];
    buffer[buffer.length-i-1] = buffer[i];
    buffer[i] = tmp;
  }
  return buffer;
}

var SerializedCellsReader = module.exports = function(buffer) {
  if (buffer === undefined)
    throw new TypeError('Missing \'buffer\' argument in SerializedCellsReader constructor');
  if (!(buffer instanceof Buffer))
    throw new TypeError('\'buffer\' argument for SerializedCellsReader constructor must be a Buffer');
  this.buffer = buffer;
  this.offset = 0;
  this.previousRow = null;
  this.flag = 0;
  this.timestamp = null;
  this.revision = null;
  this.row = null;
  this.columnFamily = null;
  this.columnQualifier = null;
  this.value = null;
  this.cellFlag = 0;

  var version = this.buffer.readUInt32LE(this.offset);
  this.offset += 4;
  if (version !== SerializedCellsVersion.SCVERSION)
    throw new Error('Invalid buffer passed to SerializedCellsReader (expected version ' +
                    SerializedCellsVersion.SCVERSION + ', but got ' + version);
};


SerializedCellsReader.prototype = {};

SerializedCellsReader.prototype.extractStringBuffer = function() {
  var startOffset = this.offset;
  while (this.offset < this.buffer.length && this.buffer[this.offset] !== 0)
    this.offset++;
  if (this.offset == this.buffer.length)
    throw new Error('Unterminated string encounterd in serialized cells buffer');
  var strBuf;
  if (this.offset > startOffset)
    strBuf = this.buffer.slice(startOffset, this.offset);
  this.offset++;
  return strBuf;
}

SerializedCellsReader.prototype.next = function() {

  if (this.offset >= this.buffer.length)
    return false;

  // flag byte
  this.flag = this.buffer[this.offset];
  this.offset++;

  // Check for EOB
  if (this.flag & SerializedCellsFlag.EOB) {
    this.offset = this.buffer.length;
    return false;
  }

  // Timestamp
  if (this.flag & SerializedCellsFlag.HAVE_TIMESTAMP) {
    this.timestamp = new Timestamp(flipBytes(this.buffer.slice(this.offset, this.offset+8)));
    this.offset += 8;
  }

  // Revision
  if (this.flag & SerializedCellsFlag.REV_IS_TS)
    this.revision = this.timestamp;
  else if (this.flag & SerializedCellsFlag.HAVE_REVISION) {
    this.revision = new Timestamp(flipBytes(this.buffer.slice(this.offset, this.offset+8)));
    this.offset += 8;
  }
  else
    this.revision = Timestamp.TIMESTAMP_NULL;

  // Row
  if (this.buffer[this.offset] === 0) {
    assert(this.previousRow, 'Mal-formed serialized cells buffer');
    this.row = this.previousRow;
    this.offset++;
  }
  else {
    this.row = this.previousRow = this.extractStringBuffer();
    assert(this.row, 'Empty row key encountered in serialized cells buffer');
  }

  // Column family
  this.columnFamily = this.extractStringBuffer();
  assert(this.columnFamily, 'Empty row key encountered in serialized cells buffer');

  // Column Qualifier
  this.columnQualifier = this.extractStringBuffer();

  // Value
  var valueLength = this.buffer.readUInt32LE(this.offset);
  this.offset += 4;
  assert(this.offset + valueLength < this.buffer.length,
         'Mal-formed value encountered in serialized cells buffer');
  if (valueLength === 0)
    this.value = null;
  else {
    this.value = this.buffer.slice(this.offset, this.offset+valueLength);
    this.offset += valueLength;
  }
  
  // Cell flag
  this.cellFlag = this.buffer[this.offset];
  this.offset++;
  if (this.cellFlag === Hypertable.KeyFlag.DELETE_ROW)
    this.columnFamily = this.columnQualifier = null;
  else if (this.cellFlag === Hypertable.KeyFlag.DELETE_CF)
    this.columnQualifier = null;

  return true;
};

SerializedCellsReader.prototype.getRow = function() {
  assert(this.row,
         'SerializedCellsReader.next() must first be called before calling this method');
  return this.row.toString();
}

SerializedCellsReader.prototype.getColumnFamily = function() {
  if (!this.columnFamily)
    return '';
  return this.columnFamily.toString();
}

SerializedCellsReader.prototype.getColumnQualifier = function() {
  if (!this.columnQualifier)
    return '';
  return this.columnQualifier.toString();
}

SerializedCellsReader.prototype.getTimestamp = function() {
  return this.timestamp;
}

SerializedCellsReader.prototype.getRevision = function() {
  return this.revision;
}

SerializedCellsReader.prototype.getValue = function() {
  return this.value;
}

SerializedCellsReader.prototype.getCellFlag = function() {
  return this.cellFlag;
}

SerializedCellsReader.prototype.getKey = function() {
  return new Hypertable.Key({row: this.getRow(),
                             column_family: this.getColumnFamily(),
                             column_qualifier: this.getColumnQualifier(),
                             timestamp: this.timestamp,
                             revision: this.revision,
                             flag: this.cellFlag});
}

SerializedCellsReader.prototype.getCell = function() {
  return new Hypertable.Cell({key: this.getKey(), value: this.value});
}
